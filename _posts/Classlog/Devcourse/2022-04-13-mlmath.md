---
title:    "[데브코스] 7주차 - DeepLearning Mathematics for Machine Learning"
author:
  name: JaeHo YooN
  link: https://github.com/dkssud8150
date: 2022-04-13 14:40:00 +0800
categories: [Classlog, devcourse]
tags: [devcourse, deeplearning]
toc: true
comments: true
math: true
#image:
#  src: /assets/img/dev/week7/day4/main.png
#  width: 500
#  height: 500
---

<br>

기계 학습에서 수학은 손실함수를 정의하고 손실함수의 최저점을 찾아주는 최적화 이론에 사용된다. 제어를 함에 있어서도 수학이 필요하다.

# 선형대수

데이터는 벡터나 행렬, 텐서 형태로 되어 있는데, 이에 대한 공간을 이해하고, 연산을 하기 위해서는 선형대수가 필요하다. 

## 벡터와 행렬

벡터는 요소의 종료와 크기를 표현한다. 

$$ x \in R^n $$

위의 식은 벡터,x 는 실수(R)이 n개만큼 존재한다는 식이다.

데이터(샘플)은 특징 벡터로 표현된다. 특징이 4개라면 4차원의 특징 벡터이다. 또는 이미지를 벡터화하면 4x4 크기의 이미지라면 16차원의 특징 벡터로 표현이 된다. 데이터 집합의 여러 개 특징 벡터는 아래 첨자(_)로 표현한다.

$$ x_1 = \left( \begin{matrix} 5.1 \\ 3.5 \\ 1.4 \\ 0.2 \end{matrix} \right)
x_2 = \left( \begin{matrix} 4.9 \\ 3.0 \\ 1.4 \\ 0.2 \end{matrix} \right)
x_3 = \left( \begin{matrix} 4.7 \\ 3.2 \\ 1.3 \\ 0.2 \end{matrix} \right)
, \cdots ,
x_n = \left( \begin{matrix} 5.9 \\ 3.0 \\ 5.1 \\ 1.8 \end{matrix} \right) $$

<br>

행렬은 여러 개의 벡터를 담은 것으로 $ x_{i,j} $ 로 표현한다. 이 때, i는 행 번호, j는 열 번호이다. 훈련 데이터셋을 담은 행렬을 설계행렬(design matrix)라 부른다. 위의 n개의 샘플들을 설계 행렬 X로 표현할 수 있다.

$$ X = \left( \begin{matrix} 5.1 \ 3.5 \ 1.4 \ 0.2 \\ 4.9 \ 3.0 \ 1.4 \ 0.2 \\ 4.7 \ 3.2 \ 1.3 \ 0.2 \\ \vdots \\ 5.9 \ 3.0 \ 5.1 \ 1.8 \end{matrix} \right) =
\left( \begin{matrix} x_{1,1} \ x_{1,2} \ x_{1,3} \ x_{1,4} \\ x_{2,1} \ x_{2,2} \ x_{2,3} \ x_{2,4} \\ x_{3,1} \ x_{3,2} \ x_{3,3} \ x_{3,4} \\ \vdots \\ x_{n,1} \ x_{n,2} \ x_{n,3} \ x_{n,4} \end{matrix} \right) $$


세로를 row, 행이라 하고, 가로를 column, 열이라 한다.

<br>

- 전치행렬 $ A^T $

행 요소와 열 요소가 뒤바뀌는 것을 말한다. 전치행렬을 사용하는 이유는 행렬 연산을 할 때 변경을 시킨다. transpose를 하여 딥러닝 연산을 한다. 예르 들어 tensorflow에서의 행렬과 pytorch에서의 행렬 형태가 다르게 입력받는다. pytorch의 경우에는 채널이 0번에 오지만, tensorflow에서는 2번에 채널이 들어간다.

$ (A^T)_{i,j} = A_{i,j} $

$ (AB)^T = B^TA^T $

원래의 벡터는 1열, n행으로 이루어져 있다. 이를 행렬로 표현하려면 전치를 해서 1행에 집어넣게 된다.

<br>

행렬을 이용하면 방적식을 간결하게 표현이 가능하다. 또한 행렬이나 벡터을 연산을 표현하기가 편하다.

<br>

특수행렬
- 정방행렬(정사각행렬)
    - n x n 크기의 행렬

$$ \left( \begin{matrix} 2 \ 1 \ 2 \\ 4 \ 3 \ 1 \\ 7 \ 23 \ 3 \end{matrix} \right) $$

- 대각행렬
    - 우하향 대각선의 요소들만 값을 가지고 나머지는 0인 행렬

$$ \left( \begin{matrix} 2 \ 0 \ 0 \\ 0 \ 3 \ 0 \\ 0 \ 0 \ 3  \end{matrix} \right) $$

- 단위행렬
    - 우하향 대각선 요소들의 값이 1이고 나머지는 0인 행렬

$$ \left( \begin{matrix} 1 \ 0 \ 0 \\ 0 \ 1 \ 0 \\ 0 \ 0 \ 1  \end{matrix} \right) $$

- 대칭행렬
    - 우하양 대각선을 기준으로 대칭인 행렬
    - 또는, 전치를 해도 동일한 행렬

$$ \left( \begin{matrix} 2 \ 5 \ 7 \\ 5 \ 3 \ 10 \\ 7 \ 10 \ 3  \end{matrix} \right) $$

<br>

- 역행렬(matrix inversion)

역행렬은 $ A^{-1} $ 로 표기하고, 특징은 $ AA^{-1} = 1 $ , 반드시 1이 된다.

<br>

### 행렬 연산

#### 행렬 곱셈

$$ c_{i,j} = \sum_{k=1,s} a_{i,k}b_{k,j} $$

$$ 행렬 A = \left( \begin{matrix} 3 \ 4 \ 1 \\ 0 \ 5 \ 2 \end{matrix} \right), 행렬 B = \left( \begin{matrix} 2 \ 0 \ 1 \\ 1 \ 0 \ 5 \\ 4 \ 5 \ 1 \end{matrix} \right) $$
을 곱하면 2*3 행렬 C이 된다.

$$ C = \left( \begin{matrix} 14 \ 5 \ 24 \\ 13 \ 10 \ 27 \end{matrix} \right) $$

이는 교환법칙(AB≢ BA)이 성립되지 않지만, 분배법칙(A(B+C) = AB+AC)이나 결합법칙(A(BC) = (AB)C)은 성립된다.

$$ a ∙ b = a^Tb = \sum_{k=1,d} a_kb_k $$

내적은 유사도를 측정하는 것이다. 두 벡터가 벌어진 정도를 본다. 이 때, 크기와 방향을 둘 다 고려해서 90도 이하의 각도를 이룬다면 양, 90도보다 크다면 음, 90도라면 0이 나온다.

이 내적은 신경망에서 내가 가지고 있는 값과 입력 데이터와 비교하여 얼마나 유사한지 비교할 때 사용한다.

<br>

행렬의 곱을 할 때는 첫번째 행렬의 행과 두번째 행렬의 열이 같아야 한다. 2x4 행렬 A에 1x4 가중치 x를 곱하면 1x2의 행렬 b가 나오게 된다. 즉, A 행렬을 입력으로 하여 가중치를 곱했더니 저차원으로 투영된다.

$$ A = \left( \begin{matrix} 4 \ -3 \ 1 \ 3 \\ 2 \ 0 \ 5 \ 1 \end{matrix} \right) ∙ \left( \begin{matrix} 1 \\ 1 \\ 1 \\ 1 \end{matrix} \right) = \left( \begin{matrix} 5 \\ 8 \end{matrix} \right) $$

행렬의 곱이란 **공간의 변환**이라 할 수 있다.

<br>

### 텐서

3차원 이상의 구조를 가진 숫자 배열을 텐서라 한다. 따라서 각 차원마다의 이름은 다음과 같다.
- 0차 : 수(Scalar)
- 1차 : 벡터
- 2차 : 행렬
- 3차이상 : 텐서

RGB 컬러 영상도 텐서에 해당한다.

- 유사도와 거리

벡터를 기하학적으로 해석을 하면 두 벡터 간의 각도를 $ \theta $ 를 가질 것이다. 이 $ \theta $ 가 작을수록 유사하다고 판단할 수 있다.

또는 코사인 유사도라는 것도 있다. 내적 등에 의해 각도를 측정하는 방법이다.

$$ cosin similarity(a,b) = \frac{a}{||a||} \cdot \frac{b}{||b||} = cos(\theta) $$

<br>

벡터의 거리(크기)는 놈, norm 으로 측정한다.

p차 벡터에서의 놈 : $$ \parallel x \parallel_p = (\sum_{i=1,d} |x_i|^v)^{\frac{1}{p}} $$

최대 놈 : $$ \parallel x \parallel_\infty = max(|x_1|,|x_2|,\cdots,|x_d|) $$

- 1차(p=1) 놈(absolute value norm or Manhattan distance) 
- 2차(p=2) 놈(euclidean norm)
- 최대(p=infinite) 놈(max norm) 

1차, 2차, 최대 놈의 물리적 의미는 크기가 1인 요소 값들을 다 연결을 해보면 다음과 같이 만들어진다. 첫번째가 1차, 두번째가 2차, 3번째가 최대 놈이다. 1차는 다이아몬드 형태가 만들어지고, 2차는 원, 3차는 정사각형이 만들어진다고 한다.

<img src="/assets/img/dev/week9/day3/norm.png">

2차 놈을 계산을 해보면 x = (3 -4 1) 일 때, 2차 놈은 $ ||x||_2 = (3^2 + (-4)^2)^{\frac{1}{2}} = 5.099 $ 가 된다. 

<br>

행렬의 크기를 재는 것은 프로베니우스 놈(probenius norm)이 있다.

$$ \parallel A \parallel_F = \left(\sum_{i=1,n} \sum_{i=1,m} a_{ij}^2 \right)^{\frac{1}{2}} $$

이를 숫자로 풀어보면 다음과 같다.

$$ \parallel ( \begin{matrix} 2 \ 1 \\ 6 \ 4 \end{matrix} ) \parallel_F = \sqrt{2^2+1^2+6^2+4^2} = 7.550 $$

<br>

이 놈을 딥러닝에서 최적값을 찾기 위해 사용한다면, 찾으러 가는 방향이 달라질 수 있다. 왼쪽 부분이 최적값, 즉 optimal point인데, 이로 이동시키도록 규제를 정하는 것이다. 

<img src="/assets/img/dev/week9/day3/regularization.png">

<br>

### 퍼셉트론

1958년에 고안한 분류기 모델로, 다양한 벡터들이 들어오면 각각을 가중치를 곱해 연산을 해서 한가지의 결과값을 얻는 구조이다.

이 때, 입력 벡터를 어떻게 처리할 것인지에 대한 함수를 활성함수(activation function) 이라 하는데, 이 때는 계단 함수를 사용한다.

0 = f(w∙x) 에서 f는 활성함수이고, 이 때, w∙x, 즉 유사도가 특정 값 T를 넘으면 1, 못 넘으면 -1을 주는 방식이다.

<br>

퍼셉트론을 물리적 의미로 보자면, 공간을 임계값으로 나누는 threshold값이 존재하고, 이를 결정 직선(decision line)이라 한다. 이는 w에 수직하고 원점으로부터 $$ T/||w||_2 $$ 만큼 떨어져 있다. 3차원에서는 결정 평면이 되고, 4차원에서는 결정 초평면이다.

<br>

<img src="/assets/img/dev/week9/day3/perceptron.png">

여러 개의 퍼셉트론으로 표현한 것을 멀티 퍼셉트론이라 한다. 그렇게 되면 1개의 퍼셉트론에 대한 출력이 아닌 여러 개의 출력이 생성된다. 이 출력은 벡터로 표시된다. j번째 퍼셉트론의 가중치 벡터가 존재할 것이고 이에 대한 벡터는 $ (w_{j1},w_{j2},w_{j3}, \cdots , w_{jd})^T $ 로 표현이 된다.

<br>

따라서 이를 이미지로 생각해보면, 이미지 32x32x3를 입력으로 하면 입력은 1열로 펴서 3072x1 의 벡터로 표현 되고, 출력이 10개로 분류를 한다면 출력은 10x1이 되어야 할 것이다. 따라서 W는 10x3072 의 행렬이 된다.

<img src="https://media.vlpt.us/images/guide333/post/9716404d-3486-4321-849f-fbb695acc0bf/Screenshot%20from%202021-01-02%2019-33-10.png">

그래서 32x32x3을 입력으로 하여 활성 함수로 집어넣으면 가중치 w와 곱해져서 퍼셉트론에 의해 출력값이 나오게 될 것이고, 그로 인해 10개의 클래스를 분류할 수 있다.

<br>

이 퍼셉트론을 여러 층으로 확장한 것을 MLP(Multi Layer Perceptron)이라 한다.

<br>

기저벡터(basis) a,b의 선형 결합으로 인해 만들어지는 공간을 벡터 공간(vector space)라 부른다.

<img src="/assets/img/dev/week9/day3/vector.png">

즉 a와 b의 결합을 하여 c라는 벡터가 추출된다면 모든 c의 경우의 점들이 그리는 공간을 벡터 공간이라 한다.

<br>

위의 이미지 벡터를 f(w∙x) 로 연산하는 과정에서 역행렬을 사용한다. 우리가 학습을 할 때는 w, 가중치를 최적값으로 만드는 것이다. 그렇다면 우리가 wx = b 라는 값이 추출되는데, w에 대해 확인해야 하므로 x를 우항으로 넘겨야 한다.

$ wx = b $
$ x^{-1}xw = x^{-1}b $
$ Iw = x^{-1}b $
$ w = x^{-1}b $

이 때, 선형 방정식의 경우 해가 유일한 경우에만 역행렬을 이용하여 해를 구한다. 그렇다면 x가 다음과 같은 필요충분조건을 가진다.

- x의 행렬식(determinant)은 0이 아니다.
- $ x^{-1}x $는 양의 정부호 대칭 행렬이다
- x의 고유값은 모두 0이 아니다.

<br>

- 행렬식

A 행렬의 행렬식(determinant)는 `det(A)`로 표기한다.

$ det(A) = ad - bc $ 로 표현하고, 행렬식이 의미하는 것은 행렬의 곱에 의한 공간의 확장이나 축소를 해석해주는 것이다. 만약 `det(A) = 0` 이라면 하나의 차원을 따라 축소되어 부피가 줄어들게 되고,  `det(A) = 1`이면 부피가 유지되고, 방향이 보존되는 변환이다. `det(A) = -1` 이라면 부피 유지되지만 방향이 보존이 되지 않는 변환이다. 또한, `det(A) = 5`이면 5배 부피가 확장되며 방향도 보존된다.

- 정부호(definiteness) 행렬

양의 정부호 행렬이란 0이 아닌 모든 벡터 x에 대해 $ x^TAx > 0 $ 인 상태를 말한다.

$$ \left( \begin{matrix} x_1 \ x_2  \end{matrix} \right) \left( \begin{matrix} 1 \ 0  \\  0 \ 2 \end{matrix} \right) \left( \begin{matrix} x_1 \\ x_2 \end{matrix} \right) = x_1^2 + 2x_2^2$$ 이르모 이 행렬은 양의 정부호 행렬이다.

양의 정부호 행렬인 경우 고유값이 모두 양수이고, 역행렬도 정부호 행렬이고, det(A) =\ 0 이다.

- 분해(decomposition)

정수 3717은 이대로는 특성이 안보이지만, 이를 소인수 분해하면 3*3*7*59로 3으로 나뉘고, 7로도 나눌 수 있다는 특성이 보인다. 따라서 행렬도 분해를 해서 특성을 확인한다.

행렬을 분해할 때는 고유값(eigenvalue) 분해를 한다. 행렬 A를 고유값 분해하는 식은 다음과 같다.

$$ Av = \lambda v $$ , 여기서 v는 고유 벡터 $ \lambda $ 는 고유값이다.

고유값 분해란 행렬 A의 특성(방향)은 변하지 않고 크기에 대해서만 커지거나 작아지는 특징을 가진다.

고유값 분해를 하면 원으로 표현된 행렬이 타원으로 변환될 수 있다.

<br>

- 고유 분해(eigen-decomposition)

$ A = QVQ^{-1} $ 이 있을 때, Q는 A의 고유 벡터를 열로 배치한 행렬이고, V는 고유값을 대각선으로 배치한 대각 행렬이다. 고유 분해는 고유값과 해당 고유 벡터가 존재하는 정사각행렬에서만 가능하다. 하지만 기계학습에서는 정사각행렬이 아닌 경우의 분해도 필요하므로 고유 분해를 사용함에 한계가 존재한다.

<br>

- 특이값 분해(SVD : singular value decomposition)

$ A = U\sum V^T $

이 때, U는 $AA^T$의 고유벡터를 열로 배치한 n x n 행렬이다. V는 $A^TA의 고유 벡터를 열로 배치한 m x m 행렬이다. $ \sum $ 은 $A^TA $의 고유값의 제곱근을 대각선에 배치한 n x m 대각 행렬이다. 

<br>

이 고유 분해와 특이값 분해를 통해 역행렬을 구할 때 쉽게 연산하기 위해서다. 특이값 분해에서 기하학적으로 접근을 해보면 V는 회전 변환, D는 크기 변환, U는 회전 변환이 된다.

특이값 분해(SVD)는 정사각행렬이 아닌 행렬의 역행렬을 계산하는데 사용된다.

$ A = U \sum V^T => A = V \sum^{-1} U^T $

<br>

<br>

# 확률과 통계

기계 학습이 처리할 데이터는 불확실한 세상에서 발생하므로 불확실성에 대한 확률과 통계가 활용된다. 

## 확률 기초

다섯가지 경우 중 한 값을 갖는 확률 변수 x는 정의역{y1,y2,y3,y4}을 가진다.

- 확률분포(probability distribution)
    - 확률질량함수(probability mass function)
        이산 확률 변수에 대한 함수다. 즉 각 확률이 discrete적인 것들에 대해서 설명된다.
    - 확률밀도함수(probability density function)
        연속 확률 변수에 대한 함수다. 즉 특정값을 지정하는 것이 아닌 범위적으로 확률을 구한다. 특정 x가 아닌 p(x)를 통해 입력값을 구한다.

- 확률벡터(random vector)
확률에 대한 벡터로 나타낸 것을 말한다. 

<br>

- 조건부 확률

x에 대한 이벤트 이후에 y에 대한 이벤트가 발생하고, 특정 조건에 만족하는 상황에 대한 확률을 구하고자 한다. 그렇다면 

$ P(Y = y | X = x) = \frac{P(Y = y, X = x)}{P(X = x)} $

<br>

- 곱 규칙과 합 규칙

곱 규칙 : $ P(y,x) = P(x|y)P(y) $

합 규칙 : $ P(x) = \sum_{y} P(y,x) = \sum_{y} P(x|y)P(y) $

이 식들은 조건부 확률 식에서 항을 이동한 것이다. 우리가 알고 싶은 것은 P(y,x)이므로 조건부 확률 식을 활용한다.

예를 들어 8개의 공이 들어 있는 주머니에서 번호를 뽑아 그 번호의 파란공과 하얀공이 들어있는 주머니에서 공을 뽑고자 한다. 이 때 번호는 1번, 공의 색은 흰색이어야 한다면, 확률은 P(y = 1, x = 흰색) 이 되는데, 이를 구하기는 어렵기 때문에, 조건부 확률 식으로 변환하여 P(x = 하양 \| y = 1) P(y = 1) 의 식이 된다.

그렇다면 하얀 공이 뽑힐 확률은 1번에서 흰색, 2번에서 흰색, 3번에서 흰색이 나올수 있다. 그 식은 다음과 같다.

$$ P(하양) = P(하양|1)P(1) + P(하양|2)P(2) + P(하양|3)P(3) = \frac{9}{12}\frac{1}{8} + \frac{5}{15}\frac{4}{8} + \frac{3}{6} \frac{3}{8} $$ 

정리하면 확률 P(x) 는 y에 대한 모든 경우의 P(y,x)를 다 합하는 것이다. 이 P(y,x)는 P(x\|y)P(y)가 된다.

<br>

- 확률의 연쇄 법칙

$ P(x_1, x_2, \cdots , x_n) $ 이라면 이는 조건부 확률에 의해 $ P(x_1) \Pi_{i=2}^n P(x_i | x_1, \cdots , x_i-1)$ 이 된다.

<br>

- 독립

x와 y 상황이 서로 영향을 미치지 않을 경우 독립이라 한다.

따라서 $ P(X = x, Y = y) = P(X = x)P(Y = y) $ 로 표현된다.

<br>

- 조건부 독립

독립은 현실에서는 거의 불가능한 조건이다. 따라서 조건에 성립될 때만 독립이라 하여 조건부 독립이라 한다.

상황 X,Y,Z 가 있을 때 Z = z일 때만 X,Y가 독립이라면 조건부 독립이다.

$ P(X = x, Y = y, Z = z) = P(X = x | Z = z)P(Y = y | Z = z) $

<br>

- 기대값

내가 원하는 값을 얻기 위해 특정 상수를 곱해주는 상황을 말한다. 즉, 확률 분포가 존재할 때 내가 원하는 출력값을 얻기 위해 가중치를 곱해주는 것이다.

$ E_{x~P}|f(x)| = \sum_x P(x)f(x) $

<br>

## 베이즈 정리

$ P(y,x) = P(x|y)P(y) = P(x,y) = P(y|x)P(x) $
$ P(y|x) = \frac{P(x|y)P(y)}{P(x)} $

`Bayes's rule`이란 P(y,x)와 P(x,y)는 같으므로 이를 활용해서 새로은 식을 만든다. 이 식은 매우 많이 사용된다.

예를 들어 흰색 공이 나왔는데, 어느 주머니인지 모르지만, 흰색 공이 나올 확률을 추정하라고 한다면 argmax를 사용한다.

$ \hat y = argmax_y P(y|x) $

x가 흰색 공인데, x가 최대가 되는 y를 알려달라는 식이다. 

이 베이즈 정리 식에서 좌항을 사후 확률(posteriori), P(x|y)를 likelihood, P(y)를 사전확률(prior)이라 한다. 기계 학습은 사후 확률을 구하는 과정이다. 우도는 관찰값을 보고 추측하는 것과 같다. 

`posteriori = likelihood * prior`

<br>

이 베이즈 정리를 iris 데이터 분류 문제에 적용을 한다면 어떻게 될까?

특징 벡터 x가 있을 때 분류 y : {setosa, versicolor, virginica} 

이 분류 문제를 argmax로 표현하면 다음과 같다.

$ \hat y = argmax_y P(y|x) $

즉, x가 주어졌을 때, 어떤 y인지에 대한 값이 분류기다. 즉, 이미지 벡터를 추정을 하여 나온 값이 다음과 같다고 생각해보자.

- P(setosa|x) = 0.18
- P(versicolor|x) = 0.72
- P(virginica|x) = 0.10

여기서 argmax 즉, 최대값은 2번째 값이 되므로 이 이미지는 versicolor 이라는 결과를 도출하게 된다. 

이 때 최대 확률을 최대 우도,max likelihood(ML)이라고도 한다. 그래서 이 ML을 추정한다고 하여 MLE 방법이 있다.

최대 우도를 추정한다는 것은, 확률 분포 $\theta$ 에 대해 $ \hat \theta = argmax_\theta P(y|\theta) $ 의 식을 가진다. 확인되는 데이터 y에 대한 확률이 최대가 되는 분포를 구한다는 것이다. 즉 입력 데이터와 확률 분포 $ \theta $ 를 통해 확률을 얻는데, 이 확률이 최대가 되도록 만들어 $ \hat \theta $ 를 얻는다. 

이 최대 우도를 추정할 때는 로그 표현을 사용한다. 그 이유는 조건부 확률은 연쇄 법칙에 의해 곱셈으로 정리되는데, 이 연산을 줄이기 위해 log를 사용하여 덧셈으로 처리한다. log는 단조 증가하는 함수이므로 최대에 대한 대상은 변하지 않는다.

<br>

분산의 경우 $\sigma^2 = \frac{1}{n}\sum_{i=1}^n(x_i-\mu)^2$ 로 표현된다. 분산의 경우 데이터가 얼마나 퍼져 있는지를 확인할 수 있다. 이 때, 차원이 늘어나면 차원과 차원과의 관계가 분산으로 표시될 것이다. 이를 공분산 행렬이라 한다. 공분산 행렬을 통해 차원사이의 상관 정도를 파악한다.

<br>

<br>

## 유용한 확률 분포

- 가우시안 분포(Gaussian distribution)

평균 $\mu$ 와 분산 $\sigma^2$ 으로 정의된다. 평균값과 퍼짐의 정도를 확인할 수 있다. 

- 베르누이 분포(bernoulli distribution)

성공 확률이 p이고 실패 확률이 1-p인 분포를 말한다.

- 이항 분포

베르누이 실험을 m번 확대한 것을 말한다.

- 혼합 분포

확률 분포를 여러개 써서 주어진 분포를 구하는 방식을 말한다. 1가지를 여러 번 사용하는 것으로 가우시안을 3개 혼합하여 사용하는 방법이 있다.

- 변수 변환

기존의 확률 분포를 새로운 확률 분포로 바꾸는 것을 말한다. 서로의 확률 분포는 상관관계가 있어야 한다. 모델 구성에는 잘 사용하지 않을 수 있지만, 데이터 생성에 많이 사용된다.

### 로지스틱 시그모이드 함수(logistic sigmoid function)

시그모이드 함수는 일반적으로 베르누이 분포의 매개변수를 조정을 통해 얻어진다. 이는 비선형 활성 함수로 딥러닝에 많이 사용되었다.

<img src="/assets/img/dev/week9/day3/sigmoid.png">

<br>

### 소프트플러스 함수

이 또한 활성함수로 많이 사용된다.

<img src="/assets/img/dev/week9/day3/softplus.png">

<br>

<br>

# 정보이론

정보이론과 확률통계는 많은 교차점을 가지고 있다. 정보이론 관점에서도 기계학습에 접근이 가능하다. 정보이론이란 사건이 지닌 정보를 불확실성에 대해 정량화하여 이용하는 방법을 말한다. 이를 기계학습에 적용한 예로는 `엔트로피`,`교차 엔트로피`, `KL 발산` 등이 있다.

확률이 작을수록 더 많은 정보를 가지고 있다. 자주 발생하는 사건보다 잘 일어나지 않는 사건의 정보량이 많다.

<br>

- 자기정보(self information)

사건이 가지는 정보량을 나타내는 것으로 $ h(e_i) = - log_2P(e_i) $ 또는 $ h(e_i) = - log_eP(e_i) $ 를 사용한다. 2를 사용하여 로그를 쓸 경우 비트(bit), 자연상수 e를 사용할 경우 나츠(nat)라고 부른다. 대체로 계산을 쉽게 하기 위해 2를 많이 사용한다.

동전이 앞면이 나오는 사건의 정보량은 $ -log_2(1/2) = 1 $이지만, 주사위에서 1이 나오는 사건의 정보량은 $ -log_2(1/6) ≓ 2.58 $ 이다. 따라서 후자의 사건이 높은 정보량을 가진다고 할 수 있다.

<br>

- 엔트로피(entropy)

자기 정보는 사건을 1개만 보는 것이다. 그래서 이벤트 1개만이 아닌 확률 변수 x의 불확실성을 나타내는 것을 엔트로피라 한다. 따라서 모든 사건 정보량의 기대값을 표현한다.

이산확률분포와 연속확률분포일 떄의 엔트로피는 다르게 표현된다.

- 이산확률분포 : $$ H(x) = - \sum_{i=1,k} P(e_i)log_2P(e_i) $$
- 연속확률분포 : $$ H(x) = - \int_R P(x)log_2P(x) $$

이 때도, $log_2$ 대신 $log_e$를 사용할수도 있다.

자기 정보에 확률을 곱해 전체 다 더했을 때 원래의 자기 정보가 되도록 만든다. 즉 이전의 주사위에서 정보량은 2.58이었는데, 여기서 확률 1/6을 곱하면 0.43이 된다. 이를 각각의 확률, 즉 6번을 더하면 2.58이 된다.

정보량 1을 전송할 때는 1비트가 필요하다. 따라서 주사위에 대한 정보량을 전송하려면 2.58비트가 필요하다.

<br>

불확실성이 가장 클 때가 엔트로피가 가장 크다.

<br>

<br>

엔트로피는 통신에 많이 사용되지만, 우리는 두 확률 분포의 유사도를 측정하는 척도로 사용할 것이다.

## 교차 엔트로피(cross entropy)

두 확률 분포 P와 Q 사이의 교차 엔트로피라는 것은 이 두 분포가 얼마나 정보를 공유하고 있는지에 대한 것이다. 교차 엔트로피의 경우 위에서는 자기 자신의 확률을 곱했지만, 이 때는 다른 확률 분포의 확률을 곱한다.

$$ H(P,Q) = - \sum_x P(x)log_2Q(x) = - \sum_{i,k}P(e_i)log_2Q(e_i) $$

이 식을 전개하면 다음과 같다.

$$ H(P,Q) = - \sum_x P(x)log_2Q(x) = - \sum_{i,k} P(e_i) log_2Q(e_i) $$ 
$$ = - \sum_x P(x) log_2 P(x) - \sum_x P(x) log_2 P(x) - \sum_x P(x) log_2 Q(x) $$
$$ = H(P) + \sum_x P(x) log_2 \frac{P(x)}{Q(x)} $$

여기서 2번째 항을 KL 발산(divergence) 수식이라 한다. 이 식에서 볼 수 있는 것은 P를 데이터 분포라 하고, Q를 예측값이라 하면 학습 과정에서는 P는 바뀌지 않는다. 따라서 교차 엔트로피를 손실함수로 사용하면 KL 발산을 최소화한다는 것과 같다.

이를 딥러닝에서 손실함수로 많이 사용한다. 출력값은 확률로 내보내기 때문에 확률값과 정답(GT)을 비교하는데 이 확률과 정답에 대한 유사도를 비교해야 한다. 

<br>


- KL 발산

두 확률분포 사이의 거리를 계산할 때 사용한다.

$$ KL([ || Q]) = \sum_x P(x) log_2 \frac{P(x)}{Q(x)} $$

<img src="/assets/img/dev/week9/day3/kl.png">

P와 Q의 차이값이 KL 영역이 된다. 그래서 P라는 데이터 분포가 있고, 내가 예측한 값을 맞추는 것이므로 Q를 P로 동일하게 만드는 것이다.

<br>

<br>

# 최적화

기계학습에서의 최적화는 훈련 데이터셋이 주어지고, 이 데이터셋에 의해 출력되는 예측값에 대해 최적의 매개변수를 찾는 것을 말한다.

주로 SGD(stochastic gradient descent)를 사용한다. 손실함수를 미분하여 최저점을 구한다. 이때는 역전파(backpropagation) 알고리즘을 사용한다.

- 매개변수의 공간

$ y = f(w \cdot x) + b $ 가 있을 때, 이 w가 만드는 공간을 매개변수 공간이라 하고, 이 매개변수 공간에서 최소의 손실함수를 출력하는 매개변수 벡터를 찾는 것이 목표다.

<br>

특징 공간은 높은 차원을 가지지만, 훈련 데이터셋의 양이 작기 때문에 완벽한 확률분포를 찾는 것은 불가능하다. 대신 적잘한 모델을 선택하고 손실함수를 정의한 후 **매개변수 공간을 탐색해서 손실함수가 최저가 되는 매개변수의 점(벡터)을 찾는 전략**을 사용한다. 

<br>

미분을 할 때는 최저점으로 도달해야 하기 때문에 미분값에 (-)를 붙여줘야 한다. 예를 들어, 초기점 x_0 = (-0.5,-0.5)^T 일 때, $f\prime (x_0) = (-2.5125, -2.5)^T $ 라면 $f\prime (x_0) $ 는 현재의 방향은 경사는 값이 커지는 방향으로 되어 있다. 그러나 우리가 원하는 것은 최저점이므로 반대방향으로 해야 한다. 따라서 $-f\prime (x_0) $ 를 해서 계산해야 한다.

<br>

- 미분의 연쇄 법칙

합성함수 f(x) = g(h(i(x))) 를 미분하면 다음과 같다.

$ f\prime (x) = g\prime (h(i(x))) h\prime (i(x)) i\prime(x) $

<br>

다층 퍼셉트론은 합성함수이다. 왜냐하면 `입력층 -\> 은닉층1 -\> 은닉층2 -\> 출력층`이 있다면 이 출력층은 은닉층2(은닉층1(입력층))의 출력값이 될 것이다. 따라서 이에 대해서 미분을 할 때도 연쇄법칙이 적용된다.

<br>

<br>

행렬 미분 방법

- 야코비언 행렬(Jacobian matrix)

행렬을 1차 편도 미분하는 방법으로 야코비언 행렬을 사용한다. 이 야코비언은 어떤 행렬에 대해 각각의 요소를 모두 미분한 값이라 할 수 있다.

<br>

- 헤세 행렬(Hessian matrix)

2차 편도 미분을 해서 얻은 행렬을 헤세 행렬이라 한다. 

<br>

## 경사 하강법

값이 낮아지는 곳으로 찾아가는 원리를 경사 하강법이라 한다.

기울기 $ g = dw = \frac{\partial J}{\partial w} $에 대해 매개변수 w의 경사 하강법의 식은 다음과 같다.

$ w = w - \rho g$

함수의 기울기를 구하여 기울기가 낮은 쪽으로 반복적으로 이동하여 최소값에 도달한다.

<br>

### batch 경사 하강 알고리즘

학습을 할 때는 반복을 해서 진행을 하는데, 한 샘플마다 경사하강을 하면 너무 오랜 시간이 걸린다. 그래서 batch(집합)단위로 나누어 샘플들의 그래디언트를 구하고 평균을 한 후 마지막에 갱신을 하기도 한다.

<br>

### 확률론적 경사 하강 알고리즘(stochastic gradient descent)

그러나 위의 방법을 사용하더라도 전체 데이터셋을 다 봐야 하기 때문에 좋은 방법은 아니다. 따라서 batch(집합)단위로 나누어 그래디언트를 각각 구해 집합 단위로 평균을 내는 것은 동일하나 batch 단위마다 즉시 갱신을 한다. 

간단하게 말해서 데이터셋이 24개가 있고, batch size를 8이라 하면 8개씩 묶어서 3개의 집합을 만든다. 그래서 1개의 batch에 대해 각 샘플마다의 그래디언트를 구하고, 이들을 평균내서, 가중치를 갱신하고 다음 batch로 넘어간다.

<br>

여기서 중요한 것은 이 경사 하강법만 사용하지 않고 제어 알고리즘을 추가해서 경사 하강한다. 제어 알고리즘에는 Momentum, Adam 등이 있다.

<br>

