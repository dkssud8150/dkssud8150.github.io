# 리눅스의 기초(1)

## linux역사, 배포판

### index

- linux의 조상, unix의 역사, 배경
- c언어는 unix를 만드는 언어
- c언어 국제 표준: ISO/IEC 9899
- UNIX의 양대산맥: SysV, BSD와 호환성 문제
- POSIX 표준 등장: 최소한의 호환성
- Linux의 등장과 성공 요인
- GNU와 Free Software Foundation
- linux 배포판: 레드햇, 데비안

## 역사를 다루는 이유

1. 표준안의 존재 의미를 알려준다.
    - 표준화된 지식과 규격은 호환성을 높이고, 효율적으로 협력가능한 작업을 가능하게 한다.
2. 지금도 표준화 이전의 세계가 존재한다.
3. 인터넷 검색에서 나오는 출처가 의심스러운 문서에 주의하자.
    - 구글, 네이버, 각종 카페 ,위키 등에서 나오는 문서들 중 틀린 정보를 걸러낼 수 있어야 한다.
4. 결론: 항상 **표준 문서**와 **공식 문서**를 먼저 보자.

<br>

역사적 배경을 다루는 또 다른 이유

- 인과관계, 상관관계를 이해할 수 있게 된다.
    - 어떤 기술이나 표준 규격이 나오게 된 인과관계를 알아두면, 역사는 반복되기 때문에 현재 사용되는 기술들이 어떻게 변해가는지 큰 숲을 볼 수 있게 된다. → 테크닉만 외우면 초급 이상이 되기 힘들다.
    - 중급/고급 엔지니어가 되려면 역사적 배경과 철학을 이해하는 것이 중요하다.
- 생각해야 할 이슈: UNIX, Linux는 무엇 때문에 만들어졌는가
    - 기술의 발전은 어떤 **결핍**을 해결하기 위해 만들어진다.
        - 결핍을 해결하는 과정은 점진적 진행되다가 특이점에서 점프하게 된다. 이런 과정 속에 기존의 것을 향상시키거나 아예 버리고 새로운 것을 만들기도 한다.
        - 기술의 발전 방향을 예측하고, 올바른 방향으로 가기 위해서는 기술의 역사적 배경, 중요한 인물들이 했던 행동이 중요하다. 또한, 기술만 볼 것이 아니라 그 기술들을 창조하거나 개선한 사람이 매우 중요하다.
        
    
컴퓨터 기술은 지적 재산과 관련이 깊기 때문에 대체적으로 폐쇄적인 성향을 띄게 된다. 하지만 폐쇄적인 환경은 호환성이나 성능의 결핍이 따라오기 마련이다. UNIX는 이를 해결하려 했다. 그 결과 UNIX는 점점 호환성, 성능이 높아졌고, Linux는 호환성 측면에서 더 높은 수준을 달성했다.
    

> key point

- 다양한 표준을 기억하고, 되도록 메모한다.
    - 표준을 준수한다는 것은 호환성을 보장한다는 것이다.
    - 어설프게 아는 것은 모르는 것보다 위험하다.
- 컴퓨터 시스템에서 **개방적 호환성**은 **교환**의 효율을 높인다.
    - 개방적인 표준이 주는 **호환성**의 장점을 생각해보자.
        - OS의 API나 개념들이 표준화되고 통일되면 개방적인 표준을 근거로 서로 다른 vendor에서 만들어지는 소프트웨어, 하드웨어의 다양한 조합이 제대로 작동된다는 보장이 가능하다.
        - 개방적인 표준을 통해 여러 소프트웨어, 하드웨어는 같은 규격 내에서 경쟁을 하면서 발전한다.

<details open>

<head> 공식 문서 </head>

UNIX: www.opengroup.org

Linux 문서 및 교육 자료

- Red Hat: access.redhat.com
- Linux Foundation: www.linuxfoundation.org

책, 만화 등

- 책: 성당과 시장 - Eric Raymond
- 책: **UNIX의 탄생** - Brian Kernighan

</details>

## Multics Project

- UNIX의 씨앗
- C언어의 시작: 포팅의 편리함을 위한 도구
- C언어 국제 표준: C99로부터 시작된 Modern C
- Multics: GE,Bell lab과 MIT AI lab의 MAC 프로젝트의 산물
    - 목표: 운영체제의 복잡한 기능을 감추고 시분할, 페이지/세그먼트 메모리 관리, 프로세스 관리, 파일 시스템, 주변장치 관리, 양방향 인터페이스 등등 다양한 기능을 실험하는 프로젝트 ( 지금의 window, osx,linux 등에는 당연히 탑재되어 있음)

ken thompson이 UNIX는 게임을 위해서 만들어졌다. 

- 게임을 어떻게 좋아해서 만들게 되었는지에 대한 뒷얘기
    
    www.bell-labs.com/usr/dmr/www/ken-games.html
    

기존의 UNIX는 Assembly로 작성되어 새로운 CPU가 나올 때마다 거의 새로 작성해야만 했다. 포팅에 너무 많은 시간이 걸린다는 말이다. 그래서 B언어를 개량해서 C언어를 개발했다.

UNIX를 C언어로 작성하여 얻게된 장점

- 하드웨어가 달라져도 rebuild 혹은 약간의 수정만으로 포팅이 가능
- 그 결과 유닉스가 여러 기계에 이식됨

C언어의 표본 책 - the C ( brian w.kernighan & dennis M.ritchie)

C언어의 특징

- 고급언어면서도 어셈블리에 버금가는 성능
- 낮은 추상화 지원
    - sudio, file 객체
- 저수준의 하드웨어 조작 가능
- 쉬운 언어적 특성

C언어 국제 표준: ISO/IEC 9899

- ANSI-C (C89): 1989년도 표준
- C99: 1999년도 표준
    - 현재 산업계의 실질적 표준

# 호환성 문제

## branches & compatibility

서로 다른 UNIX 벤더에서 다 다르게 코딩되어 실행되지 않았다. 그래서 JAVA를 탄생시키게 된다. 벤더들끼리의 스스로 표준화의 필요성이 대두되면서 전기전자공학회(IEEE)의 주도하에 규격인 파직스, POSIX 1988를 발표했다.  추후 POSIX 1003.1-1990은 ISO 승인되어 IEEE std 1003.1-1988로도 표기된다.

### Minor vendors: OSF의 등장 배경

AT&T, Sun microsystems는 업계 표준인 UNIX인 SVR4를 만들어낸다. 대기업이었던 sun microsystem은 자사의 UNIX를 solaris로 개작했다. minor vendor들은 자사의 UNIX가 SVR4에 묻히게 될것을 우려하여 DEC가 회의를 주최한다. 이에 OSF(Open software foundation)을 설립했다. OSF에서 통합 유닉스로서 OSF/1을 발표했다.

유럽의 컴퓨터 제조업체들이 open System의 표준화를 위해 출범한 단체가 X/open인데 여기서 표준화를 위해 가이드라인인 XPG(X/open Portability Guide)를 만들었다.

하지만 POSIX로는 호환성이 부족했는데 ,이때 빌게이츠의 microsoft사의 서버용 os가 제작되면서 모든 unix그룹들이 통합된다. 통합된 유닉스 단일 표준안 SUS(single unix specification)이 만들어진다.

- SUSv1: XPG 4.2 혹은 UNIX95라 명명, issue 420
- SUSv2: UNIX98 실질적인 첫 SUS 표준, issue 500
- SUSv3: SUS 2002, issue 600
- SUSv4: SUS 2007, issue 700

open System이라 하면 API와 OS 구조가 공개되어 표준이 만들어진 시스템은 UNUX가 시초로서 open system = UNIX라 하기도 하지만, Linux까지 포함시키기도 한다.

<br>

## UNIX 이후의 세계

GNU(gnu is not unix)와의 협력

linux는 gnu의 컴파일러와 각종 유틸리티의 도움이 없었다면 발전이 힘들었다.

## Linux 배포판

배포판을 분류하는 기준

- 일반적으로 패키지 시스템으로 계열을 나누고 계열 내에서 특정 벤더나 단체로 다시 나뉜다.

DEB 계열

- debian, ubuntu, mint...

RPM 계열

- RHEL, CentOS, Fedora, Suse,...

debian은 GNU사의 공식 배포판

Redhat 계열 - RPM 패키지 사용

- RHEL(redhat enterprise linux)
- fedora
- **centOS**(community enterprise operating system)
    - centOS를 사용하는 경우 EPEL을 사용하는 경우가 많다.
        - Extra Packages for enterprise linux
            - EPEL에서는 다양한 목적의 패키지를 제공
            - 따로 추가 패키지를 제공하는 이유는 라이선스나 배포 문제
            - [https://fedoraproject.org/wiki/EPEL](https://fedoraproject.org/wiki/EPEL) **

Debian 계열 - deb 패키지 사용 : 수직 버전으로 차이가 발생하는 것이 아니다. 

- **debian** linux - GNU의 Ian murdock에 의해 개발
    - 데비안 기본 - **작고 가벼운 시스템 구축이 목적**
- ubuntu linux
    - 예쁘고 사용이 편리한 데스크탑 리눅스 구축
        - 기본 설치시 가장 미려한 데스크탑을 가지고 있다.
- kail linux: security, hacking 특화

그러나 데비안은 패키지 지원이 부족하다.

배포판별 top.3 특징

- **CentOS**
    - 포털 및 스타트업 기업이 가장 많이 사용
        - RHEL의 클론이라서 엔터프라이즈 환경에서 사용하기 편리하다.
        - 엔터프라이즈 환경에서 가장 많이 쓰인다.
- Ubuntu
    - 화면이 아름답고 초보자가 쓰기 편리하다.
        - 엔터프라이즈 환경에서 사용하는데 약간 불편하고 보안이 취약하다. 소형 기기에 최적화된 스핀오프가 많아 IOT embedded에서 많이 쓰인다.
- Fedora
    - 최신 기술을 확인하기 편리하여 선행기술 개발, 보안 시스템 개발에 쓰인다.

enterprise linux

대형 시스템에 특화된 리눅스

- 대용량 웹 서비스
- cloud service
- 게임 서비스
- 증권

embedded linux

작은 기기에 특화된 리눅스

- 하드웨어는 ARM 기반의 CPU를 주로 사용
    - 안드로이드, 셋탑박스, 디지털 티비...
- 주요 임베디드 리눅스용 보드 및 모듈
    - 라즈베리파이, 오렌지파이, 라떼판다, **gateworks**...
    

### summary

- mutic로부터 unix가 탄생 = ken thompson
    - AT&T와 BSD로 갈라졌다. 갈라진 이유와 결과가 중요
    - BSD에서 Sun microsystem이 탄생
- 표준화: POSIX, X/OPEN, OSF/1의 관계
    - SysV release 4(SVR4)가 탄생 = 업계의 실질적 표준
- window NT로 인해 UNIX 업계 통합
- SUS의 탄생

# 4강

## linux설치: VMware 가상 머신 기반 ubuntu 18.04 설치

가상 머신(virtual machine)

현재 사용되는 OS위에 다른 OS를 애플리케이션처럼 운용

- 현재 운영체제: 호스트 운영체제(Host OS)
- 가상 운영체제: 게스트 운영체제(Guest OS)

장점

- 간편한 설치 및 구성, 백업

단점

- 가상화로 인한 느린 속도
- 일부 호스트 OS의 하드웨어 장치(GPU)를 사용할 수 없다.

가상 머신의 한계

- 성능 및 하드웨어 제한
    - 일정 레벨 이상의 학습을 위해서 리얼 머신에 리눅스를 설치한다.
    - 리얼 머신에서 리눅스를 직접 사용해야만 빠르게 학습 효과를 볼 수 있다.
        - 리얼 머신에 리눅스를 설치해서 사용하는 경우에는 가상 머신으로 사용하는 것보다 10배 이상의 학습 효과가 있다.

주의

- 리얼 머신에 설치하는 경우, 실수로 인해 기존 하드 디스크 내용이 날아갈 수 있다.

그래서 익숙하지 않은 경우 기존 디스크는 꼭 분리하고, 리눅스는 물리적으로 다른 디스크에 설치하고 부팅시 BIOS 메뉴로 선택하도록 하자.

가상 머신의 종류

- full virtualization(전가상화)
    - 낮은 성능의 단점 / 높은 독립성
    - 호스트 os위에서 하나의 애플리케이션으로 인식
        - 해당 애플리케이션을 hypervisor이라 지칭
    - CPU나 플랫폼에서 가상화를 돕는 가속화 기능 필요 (optional)
        - intel VT-x, VT-d, AMD-V
        
    - 종류
        - windows
            - VMware, Virtualbox(vbox), WSL(ms에서 배포한 linux)
        - OSX
            - VMware, Virtualbox(vbox), parallels
        - Linux
            - VMware, Virtualbox(vbox)
    - 라이선스
        - virtualbox는 opensource, 그 외는 상업적 소프트웨어

- para virtualiation(반가상화)

다운로드

VMware workstation player

- [https://www.vmware.com/kr/products/workstation-player/workstation-player-evaluation.html](https://www.vmware.com/kr/products/workstation-player/workstation-player-evaluation.html)

ubuntu 18.04.5

- [https://mirror.kakao.com/ubuntu-releases/18.04.6/](https://mirror.kakao.com/ubuntu-releases/18.04.6/)

 

# 5강

open-vm-tools 설치

open-vm-tools란

- VMware의 vm-tools의 패키지 버전
- 기능
    - 화면 조절: 화면 크기의 조절이 가능, 그래픽 가속
    - 클립 보드: 윈도에서 복사한 텍스트를 리눅스에 shift-insert로 붙이기 가능, 반대로 리눅스에서 복사한 것을 윈도우에 ctrl-v로 붙여넣기 가능
    - 파일 복사: 윈도 탐색기에서 파일을 끌어서 가져오기 가능(단, 드래그한 뒤 바로 놓지 말고 잠깐 기다렸다가 +기호가 보일 때 놓아야 함)

터미널을 켜서 

```bash
sudo apt install open-vm-tools{,-desktop}
그 후 재부팅해줘야 함
sudo reboot
```

그 다음 데일리 서비스를 비활성화해줘야 한다.

```bash
sudo systemctl disable --now apt-daily.timer
sudo systemctl disable --now apt-daily-upgrade.timer
```

새 unix 암호를 입력해야 한다. 그래서

```bash
~$ sudo passwd
암호 입력
재입력
그 후 확인 및 root 계정으로 바꾸기 위해
~$ su -
암호 입력
~# id
나가기 위해서는 
~# exit 또는 ctrl+D
```

가상 머신 종료할 때는 절전이 아닌 

1. terminal에서 poweroff
2. x window 우측 상단 톱니바퀴에 컴퓨터 끄기

# 6강

## VT(Virtualization Technology) 활성화, VMware: preferences

VMware setting

좀 더 편리하게 사용하기 위한 설정

1. virtual machine setting
    - processors: virtualization engine(==virtualization technology)
        - 설치 과정에는 작업했지만, 이론적인 설명이 없어 다시 복습
    - preferences 설정
        - 필수는 아니나 편리한 설정

1은 필수, 3번은 있으면 킴

# 7강

Linux 기초 - ubuntu GUI

1. 터미널 실행 → Ctrl+alt+t , 이 단축키는 설정 → 접근성 → 키보드에 가면 자기 편한 단축키로 바꿀 수 있다.
2. 글꼴 변경
    - 기본 설정 → 사용자 지정 글꼴
3. 단축키
    - 터미널 이동 → super(window키) + 마우스 좌클릭
    - 터미널 크기 조정 → super + 마우스 휠 드래그
    - 터미널 새 페이지 → ctrl + shift + t
    - 터미널 다른 페이지 이동 → ctrl + 숫자 키
    - 한영 전환 → shift + space

설정 

- 개인 정보 → 화면 잠금 해제
- 전원 → 절전 빈화면 안함

폰트 설치

```bash
$ sudo apt -y install fonts-nanum* fonts-naver*
```

# 8강

login shell and environment

운영체제(OS)란?

<img src='/assets/img/dev/os.png'>

- Modern operating system의 구성
    - kernel: 하드웨어를 제어하는 핵심 코드
    - application
        - shell : 다른 application을 구동시킴
        - web browser, music player ...
- 실행 영역에 따른 구분
    - system(kernel)
    - user (kernel의 도움이 필요 없는 영역)
        - 모든 프로세스는 user + system으로 작동된다.

UI(User interface)

- 시스템의 조작 및 통신을 위해 외부의 접속을 받아들이는 부분 ⇒ CLI/CUI, TUI, GUI
- Shell은 기본적으로 CLI/CUI 방식 사용
    - CLI(command line interface) / CUI(character user interface) ⇒ 반대되는 개념은 GUI(graphic user interface)
    - 윈도우의 cmd도 CUI방식의 일종의 shell

Command line interface 

- prompt에서 명령행 타이핑을 통해 실행
- 텍스트 베이스 방식
    - 장점: 오버헤드가 적다(서버에서는 매우 중요) ⇒ 입출력 결과를 파일로 지정 가능 (stdio)
    - 단점: 사용자 친화적이지 않다.

TUI(Text-base user interface)

- 텍스트를 이용해서 구현하는 그래픽을 사용하는 UI
    - 장점: 오버헤드 적음
    - 단점: 화면 크기, 글꼴에 따라 화면이 깨짐
- 주로 ncurses, newt 라이브러리로 구현된다.

GUI(graphical user interface)

- VGA 그래픽 방식 사용하는 UI
    - 위젯 표현을 변경
    - 장점: 섬세한 그래픽과 색상
    - 단점: 높은 통신 대역폭, 메모리가 필요하므로 높은 하드웨어 성능이 필요

UNIX/Linux는 CLI/CUI 방식을 선호한다.

- 수행 능력이 좋다. → 낮은 대역폭에서도 잘 작동 / 저전력

 

### console/terminal

console: 

사전적 의미: 건반과 패달을 가진 연주대 → 컴퓨터에 물리적으로 직접 연결된 제어용 송수신 **장치**를 의미

terminal:

사전적 의미: 종단, 끝 → 데이터를 송수신하는 목적지나 출발점이 되는 장치

따라서 콘솔은 장치의 형태, 터미널은 장치의 위치에 따른 논리적 분류 용어이다. 즉 둘은 비교 가능한 성질이 아니다. e.g) console terminal / remote terminal

물리적 위치에 따라 다음과 같이 2가지로 분류

- console terminal
    - 시스템에 물리적으로 부착되어 있는 콘솔에서 액세스한 터미널
    - terminal 부분을 생략하고 그냥 console이라 불린다.
- remote terminal
    - 원격에서 액세스한 터미널: ssh, web shell ,x terminal 등등으로 접속
    - 보통 remote를 생략하고, terminal로 부르는 경우가 많음
    - 학술적으로 보면 웹 브라우저도 terminal software에 속함
    
    <img src='/assets/img/dev/remote_terminal.png'>
    

대부분의 UNIX, Linux 서버는 text console을 사용

text console 스위칭 방법

- 일반적으로 ALT + F1 ~ ALT + F6 에 맵핑되어 있고, tty라고 부른다. F2~F7인 경우도 있다.
- 그래픽 콘솔에서 텍스트 콘솔로 이동하는 경우에는 ctrl을 조합
    - 그래서 ctrl + alt + f1 ~ 으로 이동

그래픽 콘솔 - x window를 사용하는 콘솔이라 x console이라고도 부름

x window를 원격에서 접속하면  x (remote) terminal이라 한다.

그래픽 콘솔은 F1 or F7에 맵핑된다.

- F1에 그래픽 콘솔을 맵핑하면 tty는 F2~F7, F7에 그래픽 콘솔이면, F1~F6이 tty

login의 의미

1. 접속을 요청
2. 알맞은 인증과정을 거쳐
3. 시스템 내부와 통신 가능한 상태
4. 시스템에 명령을 내릴 수 있는 인터페이스가 실행

그래픽 콘솔은 DE(desktop environment)에 따라 다르다.

- ubuntu: GNOME
- Debian, RH계열: **GNOME**, KDE,Xfce

텍스트 콘솔에서 로그인

- 시스템에서 ctrl + alt + F3 을 누른다.
- login 한다. jaehoyoon
- passwd - qwer1234
- 로그인 하고 난 후 prompt에 $ 는 일반, #는 root 유저를 의미
- 다시 그래픽 콘솔로 가고 싶은 경우 alt+f1 or alt+f7

로그인하면 session이 만들어지는데 이를 해제하는 것을 로그아웃이라 한다. 세션은 서버 측에 존재하는 출근부와 같은 것이다.

- 로그아웃할 때는 exit, logout, ctrl+D

로그아웃후에는 종료를 해야 한다. 

이때 소프트웨어적인 종료는 shutdown -h, sudo halt

하드웨어 전원을 끄는 경우 sudo poweroff

# 9강

unix 계정

계정 종류

- system account
    - root 및 system service 전용 계정
    - 로그인 불가 계정도 많다.
- normal account
    - 나중에 추가하는 로그인이 가능한 일반 유저

계정의 권한을 분리하고, 접근할 수 있는 디렉토리와 파일, 프로세스를 구분

user, group 관리 명령어

- user:
    - useradd(추가), usermod(수정),userdel(삭제)
    - id, whoami
- group
    - groupadd,groupmod, groupdel

user 교체, 권한 명령어

- user
    - su ( substitute user )
    - passwd
- group
    - newgrp ( log in to a new group )
    - gpasswd

su - 

- - 지정시 login shell로 작동한다. root 유저로 바꿀 때 사용

<img src='/assets/img/dev/envmentlist.png'>

외우는 것은 아니고, 알아두기만 하면 됨

# 10강

## man page

unix 계열은 CLI로 작동하는 online manual이 있다.

- 이를 man page라 한다,
- 구글링 전에 man page를 먼저 보자
- 표준 unix 명령어는 xpg로부터 유래

man [option] <item>

e.g. man ueradd, man -f printf

문법 표기

- 무괄호, <> : 필수 항목
- []: 선택가능한 항목

문법 표기 예제

- shutdown [-rhc] time [message]
    - -rhc와 message는 생략 가능
    - time은 생략 불가능

man page: 출력 언어

언어 설정에 따라 다른 언어로 출력될 수 있다.

한국어 설정 상태에서 man페이지를 보면 한국어 메뉴얼이 존재하면 한국어, 한국어 매뉴얼이 존재하지 않으면 영어

그냥 영어로 보는 것을 추천

x window에서 터미널 실행 후 man 페이지를 보자

```bash
man su
```

text console은 한글을 표시할 수 없다.

LANG 환경 변수

- locale + character set
    - locale: 사용자의 언어 및 지역 정보
        - language: ISO 639-1
        - contry: ISO 3166-1
    - character set:  입출력 문자표

LANGUAGE를 사용하는 경우 그냥 비워두는 것이 좋다.

```bash
~$ export LANGUAGE=
```

export LANG = C라고 하면 영문을 말한다.

man su에서 한글이 깨지게 나오면 영문 모드(export LANG=en_US.UTF-8)로 바꾸면 된다.

로케일 생성 명령어

```bash
~$ locale-gen ja_JP.utf8
```

system의 locale을 확인 및 설정

```bash
localectl set-locale LANG=en_US.utf8
```

로케일을 변경 후 재로그인하면 된다.

putty / mobaxterm

외부에서 터미널을 통해 윈도우즈에 접속하는 경우 putty/mobaxterm 을 사용하는데, 여기서

창 → 변환 → 수신한 데이터를 UTF-8로 변경해야 함

✨가장 중요한 부분

```bash
~# export LANG=en_US.utf8; export LANGUAGE=
```