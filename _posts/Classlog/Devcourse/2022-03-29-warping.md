---
title:    "[데브코스] 7주차 - ROS wraping transformation "
author:
  name: JaeHo YooN
  link: https://github.com/dkssud8150
date: 2022-03-29 14:01:00 +0800
categories: [Classlog, devcourse]
tags: [devcourse, ros, transformation]
toc: True
comments: True
# image:
#   src: /assets/img/dev/week6/calra/main.jpg
#   width: 800
#   height: 500
---

<br>

# Warping

사전적으로 뒤틀림이라는 의미로, 영상에서 말하는 warping은 이동, 회전, 크기 변환 등을 말한다. 찌그러진 이미지를 복원할 수도 있다.

## ROS 환경 설정

1.패키지 생성
- `sliding_drive` 패키지를 생성

```bash
$ catkin_create_pkg sliding_drive std_msgs rospy
```

<br>

2.src 폴더 아래 girl.png, chess.png 파일 복사

<br>

## Translation 변환

**1.평행이동**

- 이미지를 이동하려면 원래 있던 좌표에 이동시키련느 거리만큼 더하면 된다.
    - x_new = x_old + d1
    - y_new = y_old + d2

이를 변환 행렬로 표현하면

<img src="/assets\img\dev\week7\day2\matrix.png">

따라서 
- x_old + d1 = 1 * x_old + 0 * y_old + d1
- y_old + d2 = 0 * x_old + 1 * y_old + d2

<br>

`dst = cv2.warpAffine(src, matrix, dsize, dst, flags, borderMode, borderValue)`

- src : 원본 이미지, numpy 배열
- matrix : 2x3 변환 행렬, dtype=float32
- dsize : 결과 이미지의 크기
- dst : option,결과 이미지
- flags : option, 보간법 알고리즘 플래그
    - cv2.INTER_LINEAR : default, 인접한 4개 픽셀 값에 거리 가중치 사용
    - cv2.INTER_NEAREST : 가장 가까운 픽셀 값 아용
    - cv2.INTER_AREA : 픽셀 영역 관계를 이용한 재샘플링
    - cv2.INTER_CUBIC : 인접한 16개 픽셀 값에 거리 가중치 사용
- borderMode : option, 외곽영역 보정 플래그
    - cv2.BORDER_CONSTANT : 고정 색상 값
    - cv2.BORDER_REPLICATE : 가장자리 복제
    - cv2.BORDER_WRAP : 반복
    - cv2.BORDER_REFLECT : 반사
- borderValue : option, 외곽영역 보정 플래그가 cv2.BORDER_CONSTANT일경우 사용할 색상 값

<br>

```python
import cv2
import numpy as np

img = cv2.imread('girl.png')0
rows, cols = img.shape[0:2]

dx,dy=100,50

mtrx = np.float32([[1,0,dx],[0,1,dy]])

dst = cv2.warpAffine(img,mtrx, (cols+dx, rows+dy))

dst2 = cv2.warpAffine(img,mtrx, (cols+dx, rows+dy),None, cv2_INTER_LENEAR, cv2_BORDER_CONSTANT, (255,0,0))

dst3 = cv2.warpAffine(img,mtrx, (cols+dx, rows+dy),None, cv2_INTER_LENEAR, cv2_BORDER_RELECT)

cv2.imshow("src",img)
cv2.imshow("dst",dst)
cv2.imshow("constant",dst2)
cv2.imshow("reflect",dst3)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

<br>

- 실행
```bash
$ python translation.py
```

<br>

2.확대축소

일정 비율로 확대 및 축소

기존 좌표에 특정 값을 곱하면 된다.
- x_new = a1 * x_old = a1 * x_old + 0 * y_old + 0 * 1
- y_new = 0 * x_old = a1 * x_old + a2 * y_old + 0 * 1

이를 변환 행렬로 표현하면 다음과 같다.

<img src="/assets\img\dev\week7\day2\matrix2.png">

<br>

```python
import cv2
import numpy as np

img = cv2.imread('girl.png')0
rows, cols = img.shape[0:2]

mtrx_small = np.float32([[0.5,0,0],[0,0.5,0]])
mtrx_big = np.float32([[2,0,0],[0,2,0]])

dst = cv2.warpAffine(img,mtrx, m_small, (int(height*0.5), int(width*0.5)))

dst2 = cv2.warpAffine(img,mtrx, m_small, (int(height*0.5), int(width*0.5)), None, cv2_INTER_AREA)

dst3 = cv2.warpAffine(img,mtrx, m_big, (int(height*2), int(width*2)))

dst4 = cv2.warpAffine(img,mtrx, m_big, (int(height*2), int(width*2)),None, cv2_INTER_CUBIC)

cv2.imshow("src",img)
cv2.imshow("small",dst)
cv2.imshow("small_inter_area",dst2)
cv2.imshow("big",dst3)
cv2.imshow("big_inter_cubic",dst4)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

이미지를 축소할 때는 INTER_AREA를 권장하고, 확대할 때는 INTER_LINEAR 또는 CUBIC을 추천한다.

<br>

<br>

affine 이외에 다른 함수를 이용해서도 크기를 조정할 수 있다.

`cv2.resize(src,dsize,dst,fx,fy,interpolation)`

- src : 입력 원본 이미지
- dsize : 출력 영상 크기, 지정하지 않으면 fx,fy 배율을 적용
- fx,fy : 크기 배율, dsize를 입력하면 dsize를 우선 적용함
- interpolation : 보간법 알고리즘
- dst : 결과 이미지

<br>

```python
import cv2
import numpy as np

img = cv2.imread('girl.png')
height, width = img.shape[0:2]

dst1 = cv2.resize(img, (int(width*0.5), int(height*0.5)), interpolation=cv2.INTER_AREA)

dst2 = cv2.resize(img, None, None, 0.5,1.5, interpolation=cv2.INTER_CUBIC)

cv2.imshow("src",img)
cv2.imshow("small",dst)
cv2.imshow("small_inter_area",dst2)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

<br>

- 실행
```bash
$ python resizing.py
```

<br>

3.회전

이미지 회전을 위한 변환 행렬식은 다음과 같다.

![](2022-03-29-15-02-43.png)

이 2x2 행렬은 2x3을 요구하는 affine행렬에서는 사용할 수 없고, 사용히려면 2x3행렬로 변환해야 한다. 변환해주는 cv2.getRotationMatrix2D 함수가 존재한다.


회전 행렬을 직접 구현한 코드이다.

```python
import cv2
import numpy as np

img = cv2.imread('girl.png')
rows, cols = img.shape[0:2]

d45 = 45.0 * np.pi / 180
d90 = 90.0 * np.pi / 180

mtrx1 = np.float32([[np.cos(d45), -1*np.sin(d45),cols//2],[np.sin(d45),np.cos(d45),-1*rows//4]]) 

mtrx2 = np.float32([[np.cos(d90), -1*np.sin(d90),cols],[np.sin(d90),np.cos(d90),0]])

dst1 = cv2.warpAffine(img,mtrx1,(cols,rows))
dst2 = cv2.warpAffine(img,mtrx2,(cols,rows))

cv2.imshow("src",img)
cv2.imshow("45",dst)
cv2.imshow("90",dst2)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

컴퓨터는 반시계를 +로 잡기 때문에 시계방향으로 돌리기 위해 -1을 곱했고, 원점을 화면의 중간으로 잡기 위해 마지막 인자를 주었다.

<br>

회전 행렬을 함수를 사용하여 구현한 코드이다.

`mtrx = cv2.getRotationMatrix2D(center, angle, scale)`

- Center : 회전축 중심 좌표
- angle : 회전할 각도, 60진법
- scale : 확대 축소 비율

```python
import cv2
import numpy as np

img = cv2.imread('girl.png')
rows, cols = img.shape[0:2]

d45 = 45.0 * np.pi / 180
d90 = 90.0 * np.pi / 180

mtrx1 = cv2.getRotationMatrix2D((cols/2,rows/2), 45, 0.5)

mtrx2 = cv2.getRotationMatrix2D((cols/2,rows/2), 90, 1.5)

dst1 = cv2.warpAffine(img,mtrx1,(cols,rows))
dst2 = cv2.warpAffine(img,mtrx2,(cols,rows))

cv2.imshow("src",img)
cv2.imshow("45",dst)
cv2.imshow("90",dst2)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

<br>

## Affine 변환

Affine 변환 행렬은 2x3 행렬로 cv2.getAffineTranform 함수를 통해서 얻을 수 있다.

```python
import cv2
import numpy as np
from matplotlib import pyplot as plt

img = cv2.imread('chess.png')
rows, cols = img.shape[0:2]

pts1 = np.float32([[50,50],[200,50],[50,200]])

pts2 = np.float32([[10,100],[200,50],[100,250]])

mtrx = cv2.getAffineTransform(pts1,pts2)

dst = cv2.warpAffine(img,mtrx,(cols,rows))

plt.subplot(121),plt.imshow(img), plt.title('input'))
plt.subplot(122),plt.imshow(dst), plt.title('output'))
plt.show()
```

<br>

## Perspective 변환

원근법을 적용한 변환으로 직선의 성질만 유지가 되고 선의 평행성은 유지되지 않는 변환이다. 즉 원근법이 되어 있는 이미지를 평평하게 펴준다. 반대의 변환도 가능하다.

`cv2.getPerspectiveTransform` 함수를 통해서 얻을 수 있다. 이동할 4개의 점의 좌표가 필요하다. 결과값은 3x3 행렬이다. `cv2.warpPerpective()`함수에 변환 행렬값을 적용하면 이미지가 변환된다. 점의 순서는 좌상단부터 시작하여 반시계방향이다.

<br>

```python
import cv2
import numpy as np
from matplotlib import pyplot as plt

img = cv2.imread('chess.png')
rows, cols = img.shape[0:2]

pts1 = np.float32([[20,20],[20,280],[380,20],[380,280]])

pts2 = np.float32([[100,20],[20,280],[300,20],[380,280]])

cv2.circle(img,(20,20),20, (255,0,0),-1)
cv2.circle(img,(20,280),20, (0,255,0),-1)
cv2.circle(img,(380,20),20, (0,0,255),-1)
cv2.circle(img,(380,380),20, (255,255,255),-1)

mtrx = cv2.getPerspectiveTransform(pts1, pts2)

dst = cv2.warpPerspective(img, mtrx, (400,300))

plt.subplot(121),plt.imshow(img), plt.title('input'))
plt.subplot(122),plt.imshow(dst), plt.title('output'))
plt.show()
```

<br>

<br>

이 변환을 차선 검출에 적용한다면 perspective 변환을 적용할 것이다. 이렇게 변환한 영상을 bird eye view라고 한다. 이렇게 변환한다면 차선을 찾기가 편하게 된다. 

<br>

