---
title:    "[데브코스] 7주차 - DeepLearning AI & machine learning"
author:
  name: JaeHo YooN
  link: https://github.com/dkssud8150
date: 2022-04-12 14:40:00 +0800
categories: [Classlog, devcourse]
tags: [devcourse, deeplearning]
toc: true
comments: true
math: true
#image:
#  src: /assets/img/dev/week7/day4/main.png
#  width: 500
#  height: 500
---

<br>

# 기계 학습

어떤 컴퓨터 프로그램이 T라는 작업을 수행할 때, 이 프로그램의 성능이 P라는 척도로 평가했을 때 경험 E를 통해 성능이 개선된다면 이 프로그램은 학습한다고 말할 수 있다. 따라서 최적의 알고리즘을 찾는 행위를 기계 학습이라 할 수 있다. 기계 학습의 중심은 경험, 과업, 성능에 있다.

예전에는 지식 기반의 학습을 했다. 즉, 인간이 알고 있는 사실을 기계에 전달하여 학습을 하는 것을 말한다. 그러나 인간의 지식이 실제로는 틀린 것일 수 있기 떄문에 변화되었다. 그래서 기계학습으로 넘어왔다. 또한, 사람의 신경망을 모방하여 만든 심층 학습이 나오게 되면서 기계학습 분야가 더 발전하게 되었다.

기계학습으로 넘어오면서 데이터가 매우 중요해졌다. 데이터를 통해 학습하여 규칙을 찾고 그를 통해 다음을 예측하기 때문이다. 예측에는 회귀와 분류로 나뉘어진다. 회귀는 목표치가 실수이고, 분류는 특정 부류나 종류의 값을 출력한다. 예를 들어, 분류는 개와 고양이를 분류하는 것이고, 회귀는 좌표점 n개를 통해 다음 점을 예측하는 것이 회귀에 해당한다.

기계학습에서 훈련이란 주어진 task에 대해 가장 정확하게 할 수 있게 최적의 매개변수를 찾는 작업이다. 처음에는 임의의 매개변수를 지정하여 시작하지만, 학습하면서 최적의 성능에 도달한다.

훈련이 끝나면 추론, infernce를 수행한다. 훈련 데이터가 아닌 새로운 데이터를 입력으로 받아 예측을 한다. 기계학습의 궁극적인 목표는 추론에 대한 오류를 최소화하는 것이다. 테스트 데이터에서 높은 성능을 일반화,generalization 능력이라 부른다.

그렇다면 기계학습에서 필수로 있어야 할 것들은 학습을 위한 데이터를 가지고 있어야 하고, 데이터 사이의 규칙이 존재해야 한다.

데이터에는 training set, validation set, test set 이 있다. training set은 기계가 훈련하는 셋이고, test set은 훈련된 모델에 추론하고자 하는 데이터를 넣을 때 어떻게 출력되는지에 대한 셋이다. 그렇다면 validation set이 의미하는 것은, test와 비슷하다. 그러나 training set으로 훈련된 모델이 test set으로 바로 평가를 하게 되면 정확도가 떨러질 수 있다. 또한, training set만 사용하여 훈련 후 test set에 적용시키면 과적합,overfitting이 발생하기 쉽다. 그래서 validation set을 통해 훈련 시에도 평가를 함께 수행하며 학습할 수 있다.

<br>

## 특징 공간의 이해

모든 데이터는 정량적으로 표현되며, 특징 공간 상에 존재한다. 1차원, 2차원 등이 있는데, 이 각각의 차원이 의미하는 바는 각각 서술하고 있는 특징의 개수라 할 수 있다. 즉, 특징이 1개뿐이라면 1차원, 2개가 있다면 2차원이라 할 수 있다. 

iris 데이터는 4개의 특징 요소를 가지고 있다. 따라서 이는 4차원 특징 공간이라 할 수 있다. 사진을 생각해보면 각각의 픽셀이 값을 가지고 있으므로 4x4 픽셀이라면 각각의 픽셀값을 가질 수 있으므로 16차원이라 할 수 있다. 

따라서 d차원의 데이터라 하면 d개의 특징 벡터를 가진다. d차원의 특징 공간인 직선 모델을 사용할 경우, 필요한 매개변수의 개수는 d+1이다.

$$ y = w1x1 + w2x2 + ... + wdxd + b $$

d+1인 이유는 차수가 1인 x에 대해 d개를 가지고, 0차수인 상수, b를 가지기 때문이다. 그렇다면 2차원 곡선 모델을 사용한다면 매개변수의 수는 지수적으로 증가하여 d^2+d+1 개가 필요하다.

따라서 iris 데이터는 4차원이었으므로, 2차 곡선 모델을 사용한다면 4^2 + 4 + 1 이므로 21개의 매개변수가 필요하다. MNIST 데이터를 사용할 경우 d = 784 이므로 총 615,441개의 매개변수가 필요하다.

<br>

이 특징 벡터 사이의 거리를 구할 때 다양한 거리 공식이 있다. 유클리디안 거리, 맨허튼 거리 등등이 존재하기 때문에 상황에 맞게 잘 적용해야 한다.

<br>

> 차원의 저주
>
>차원이 높아짐에 따라 발생하는 현실적인 문제들이 있다. 차원이 높으면 예측이 더 잘 되지만, 차원이 높아질수록 유의미한 표현을 찾기 위해 지수적으로 더 많은 데이터가 필요하다. 그래서 이를 **차원의 저주**라 한다.


<br>

특징 공간을 직선 모델을 사용하여 분류한다면 규칙을 찾기 어렵다. 따라서 decision boundary, 경계선을 잘 설정해야 한다. 이를 위해서 데이터를 새로운 공간 좌표로 다시 변환하여 분류할 수 있다.

따라서 이 표현, 즉 데이터를 새로운 공간좌표로 변환하는 학습인 표현 학습도 중요하다. 표현 학습이란 기계가 예측하기 좋은 특징 공간을 자동으로 찾는 것을 말한다. 

표현 학습에는 HOG(Histogram of oriented gradients)가 있다. nearest neighbor 알고리즘이 나오기 전에 사용되었던 방법으로 이미지에 대한 히스토그램을 그려 분석하는 방법이다. 표현 학습에도 심층 학습이 있다. NN 방법 이후에 이미지의 특징 벡터를 딥러닝이 학습해서 특징을 추출하여 최적의 계층적인 특징을 학습하는 방법을 말한다. low level에서는 선이나 구석점 등을 추출하고, high level에서는 조금 더 추상화된 특징(얼굴, 바퀴)를 추출한다.  이는 이미지 뿐만 아니라 텍스트, 언어 등 많은 곳에 이용된다.

<img src="/assets/img/cs231n/2021-09-12/hog.png">

<img src="https://cs231n.github.io/assets/knn.jpeg">

<br>

# 데이터 생성 과정

기계학습에는 모델을 만드는 것 이외에도 데이터를 전처리하거나 수집하는 것도 중요하다. 데이터를 잘 수집하고, 잘 정제해야 정확도도 향상된다. 문제는 데이터의 양이 어느정도 많아야 할까? MNIST 데이터를 기준으로 보면 차원이 784차원이다. 이것이 흑백 이미지여서 0 또는 1로 이루어져 있다고 하더라도 서로 다른 총 샘플 수는 2^784가지가 된다. 그러나 MNIST의 경우 6만 개의 샘플로만 훈련되어 있다. 그렇다면 이 매우 작은 데이터로 어떻게 높은 성능을 보이는지 파악해봐야 할 것이다. 1과 2, 또는 2과 6의 데이터간에는 군집, 데이터가 모여있는 곳이 생긴다. 즉 scatter, 흩어져 있지 않고, 이미지마다 모여 있는 공간이 존재할 것이다. 

또한, 온전한 이미지가 있는 이미지 외에 잘려있는 이미지는 입력시키지 않는다. 이도 비슷하게 이상한 데이터를 집어넣지 않음으로서 데이터들이 흩어져 있지 않을 것이다. 

고차원의 공간을 저차원으로 바라보는 방법을 **매니폴드 가정** 이라 한다. 고차원의 데이터의 규칙은 관련된 낮은 차원에서도 특징이 연관되어 있을 것이다. 이를 매니폴드라 한다.

추가적으로, 데이터가 충분한 양만큼 수집하면 성능이 올라가지만, 데이터가 적다면 모델이 과적합(overfitting)이 발생하게 된다. 즉, 훈련 데이터에만 매우 높은 성능을 보이지만, 테스트에서는 좋지 않은 성능을 보이는 상황을 말한다. 이를 해결하기 위해서는 데이터를 많이 늘리거나, 데이터 증강을 통해 데이터를 늘려야 할 것이다.

<br>

## 데이터 가시화

4차원 이상의 초공간(hyperplane)은 한꺼번에 가시화(visualization)가 불가능하다. 따라서 여러 가지 가시화 기법을 통해 특징 벡터를 나타낼 수 있다. 

<br>

# 선형 회귀(linear regression)

직선 모델을 사용하므로 두 개의 매개변수(w,b)를 가진다. 또한, 성능을 평가하기 위해 사용하는 함수를 **목적 함수**(object function) 또는 비용 함수(cost function)이라 한다. 선형 회귀에서는 MSE(mean squared error)를 사용한다.

$$ J(\theta) = {1 \over n} \sum_{i=1}^n(f_\theta(x_i) - y_i)^2 $$ 

<!-- https://huni0318.github.io/blog/blog-etc/2020-12-21-markdown-tutorial2/ -->

f\theta는 우리가 설정한 직선을 말하고, f(x)는 예측값, y는 실제값에 해당한다. 즉, 우리가 예측한 예측값과 실제값의 차이의 평균을 오차로 평가하는 함수를 비용 함수라 한다. 처음에는 최적의 매개변수를 모르기 때문에 임의의 난수로 설정하고 개선해 나간다. 

최적화에는 convex와 nonconvex가 존재한다. 회귀 문제에서는 최적값이 1개인 것과 정확한 최적값이 존재하지 않을 수 있다. 1개인 것을 convex, 신경망과 같이 완벽한 최적값이 없거나 찾기 너무 어려운 것을 non convex라 한다.

기계학습은 개선을 통해 오류를 줄이고, 그를 통해 최적의 해를 찾아간다. 이를 공식화하면 다음과 같다.

$$ \widehat{\theta} = argmin(J(\theta)) $$

<br>

non convex에서 최적값을 찾기 위해서는 gradient를 사용한다. 그 이유는 미분값이 작아지는 방향으로 계속 가다보면 오류가 줄어들고, 결국에는 최적의 상황에 도달하기 떄문이다. 이는 산에서 골짜기를 연상하면 이해하기 쉽다.

<img src="\assets\img\dev\week9\day2\gradient_descent.jpeg">

<br>

# 과적합(overfitting)/과소적합(underfitting)

과소적합이란 모델의 용량이 작아 오차가 클 수 밖에 없는 현상을 말한다. 간단하게 선형 모델을 사용하면 당연히 경계선을 설저아기 어려울 것이다. 차수가 높을 수록 주어진 데이터에 적합하게 설정할 수 있다. 그러나 너무 큰 차수를 사용하거나 데이터의 양이 너무 작아 훈련 데이터셋에만 적합시키게 되면 test시 성능이 잘 나오지 않는다. 모델의 용량이 너무 크기 떄문에 학습 과정에사 잡음까지 수용하여 훈련시켰기 때문일 것이다. 이를 간단하게 말해서 훈련 데이터셋을 단순 암기했다고 할 수 있다.

1~2차의 모델을 사용할 경우 훈련 데이터셋과 테스트 데이터셋 모두 낮은 성능을 보이는 과소적합이 발생한다. 12차와 같이 높은 차원의 모델의 경우 훈련 데이터셋에서는 높은 성능을 보이나 테스트 데이터셋에서는 낮은 성능을 보이는 과적합이 발생한다. 이는 낮은 일반화 능력을 가졌다고 할 수 있다.

대체로 딥러닝에는 파라미터가 매우 많기 때문에 과소적합보다는 과적합이 더 많이 발생한다.

<br>

## 편향(bias) and 분산/변동(variance)

훈련 데이터셋을 여러 번 수집하여 1~12차에 반복 적용해서 실험해보면 

- 2차는 매번 큰 오차 -\> 편향이 큼(underfitting), 하지만 비슷한 모델을 얻음 -\> 낮은 변동
- 12차는 매번 작은 오차 -\> 편향이 작음, 하지만 크게 다른 모델을 얻음 -\> 높은 변동 -\> overfitting 발생

일반적으로 용량이 작은 모델은 편향이 크고 분산이 작다. 그러나 복잡한 ㅗㅁ델의 경우 편향이 작고 분산이 크다. 즉 낮은 차수의 경우 비슷한 모델이 수집되지만, 높은 차수의 경우 매번 아예 다른 모델이 수집될 수 있다.

기계 학습의 목표는 낮은 편향과 낮은 분산을 가진 예측 모델을 만드는 것이 목표다. 하지만 모델의 편향과 분산은 **상충 관계**에 있다. 따라서 적절한 optimal capacity를 잡아 **편향을 최소로 유지하고 분산도 최대로 낮추는 전략이 필요**하다. 최근에는 capacity를 크게 잡고, 점점 줄여나가는 방식을 사용한다.

<img src="/assets/img/dev/week9/day2/capacity.png">

<br>

그러나 요즘에는 서로 다른 차수를 선택해서 학습하지 않는다. 지금은 용량이 충분히 큰 모델을 선택한 후 선택한 모델이 정상을 벗어나지 않도록 규제(regularization) 기법을 적용한다. 이 때 말하는 규제는 데이터 증강(data augmentation)이나 learning rate, weight decay 설정 등을 말한다.

[regularization](https://dkssud8150.github.io/posts/cs231n3/)


<br>

## Validation set 설정

검증 데이터를 사용하여 훈련 데이터셋으로 훈련된 모델의 성능을 측정한다. 그래서 가장 높은 성능을 보인 모델을 선택한다. 그것을 사용하여 테스트에서 예측을 수행하면 좋은 성능을 보인다.

### K-fold Cross validation

데이터의 양이 적은 경우 검증 데이터셋을 돌아가며 사용하는 것을 말한다. k-fold라는 것은 훈련 데이터셋을 10개로 나누고, epoch, 반복마다 1개씩 validation set으로 설정하여 검증한다. 그래서 추출된 검증 데이터셋의 성능이 총 10개가 나오는데, 이를 평균내서 가장 좋은 성능의 모델을 선택한다.

[kfold cross validation 코드](https://dkssud8150.github.io/posts/Kfold/)

<br>

### 부트스트랩(bootstrap)

데이터 분포가 불균형할 때 사용하는 방법으로, 임의의 복원 추출 샘플링(sampling with replacement)을 반복한다. 데이터 불균형은 이상탐지(보안 분야)에서 많이 발생한다.

<img src="/assets/img/dev/week9/day2/bootstrap.png">

예를 들어, 1과 2를 분류하는데 1에 대한 데이터셋이 10000개고 2에 대한 데이터셋이 100개라면 이는 데이터 불균형에 해당된다. 200개의 데이터셋을 사용하고자 할 때는 1에 대해서는 계속 다른 데이터를 사용할 수 있지만, 2에 대해서는 100개 전체를 계속해서 추출해서 학습을 시킨다. 그렇게 많은 성능들을 어샘블링해서 판단한다.

<br>

# Regularization

## Data Augmentation

데이터를 많이 수집할수록 일반화 능력이 향상된다. 그러나 수집할 수 있는 데이터의 양은 한정적이다. 또한 데이터를 실측자료(ground truth)를 사용하려면 사람이 직접 라벨링해야 한다. 그러므로 현재 가지고 있는 데이터로 crop, perspective, rotation, warping 등과 같은 이미지를 변형(transform)함으로써 데이터를 증강시켜 robust한 모델을 생성한다. 단 원 데이터의 고유 특성이 변하지 않도록 주의해야 한다.

<br>

## Weight Decay

가중치를 줄이는 기법으로, 모델의 용량을 낮추면서 overfitting을 방지한다. overfitting이라는 것은 모델의 용량이 커서 발생하는 것이므로, 이를 감소시키게 하여 overfitting이 발생하지 않도록 조절해야 한다. 

$$ J(\theta) = {1 \over n} \sum_{i=1}^n(f_\theta(x_i) - y_i)^2 + \lambda \parallel \theta \parallel ^2 $$ 

원래 있던 훈련 집합의 오차에 선호(preference) 항을 추가하여 가중치를 감소시키도록 최적화를 시킨다.

<br>

이는 optimizer을 생성할 때 `weight decay`라는 인자를 통해 설정한다. 

[overfitting 방지하는 방법](https://dkssud8150.github.io/posts/overfitting/)

<br>

규제에는 다양한 방법들이 있다.
- parameter norm penalty
- early stopping
- bagging (bootstrap aggregation)
- dropout
- ensemble

여기서 dropout과 ensemble을 많이 사용한다.

[dropout/ensemble 참고 자료](https://dkssud8150.github.io/posts/cs231n7/)

<br>

<br>

# 기계 학습 유형

## 지도 방식에 따른 유형

- 지도 학습(supervised learning)

특징 벡터 X와 목표치 Y가 모두 주어지는 상황을 말한다. 즉 데이터와 라벨이 모두 주어진다. 회귀와 분류 문제로 구분한다.

<br>

- 비지도 학습(unsupervised learning)

특징 벡터 X만 주고, 라벨 Y를 주지 않는 상황을 말한다. 군집화(clustering)작업을 할 때 사용한다. 또는 밀도 추정, 특징 공간 변환 작업도 한다.

<br>

- 강화 학습(reinforcement learning)

<img src="https://dkssud8150.github.io/assets/img/cs231n/2021-11-09/0013.jpg">

목표치가 주어지는데 지도 학습과는 다른 형태로, 강화학습에는 에이전트, 환경, 행동이 존재한다. 에이전트는 행동에 따른 적절한 보상(reward)를 받는다. 에이전트는 어떤 행동을 했을 때 보상을 받는지에 대해 학습한다.

바둑에서 강화학습이 사용되는데, 수를 두는 행위가 샘플이고, 게임이 끝나면 목표치 하나가 부여된다. 이기면 1, 패하면 -1이다.

> 예를 들어, 고양이가 있고, 빨간색 버튼을 누르면 간식이 나오는 기계가 있다고 가정해보자. 고양이는 어떻게 해야 간식이 나오는지 모를 것이다. 아무거나 다 시도해보다가 버튼을 눌렀을 때 간식이 나오는 것을 확인한다. 이 때, 고양이(agent)는 간식이 나오는 기계(environment)의 버튼을 누르면(action) 간식 나온다는(rewards) 것을 학습한 것이다.

<br>

- 준지도 학습(semi-supervised learning)

일부는 X와 Y를 모두 가지지만, 나머지는 X만 가진 상황이다. 대부분의 데이터가 X의 수집은 쉽지만 Y는 수작업이 필요했기 때문에 주목받고 있다.

<br>

## 다양한 기준에 따른 유형

- 오프라인 학습(offline learning)과 온라인 학습(online learning)

오프라인 학습이란 데이터를 수집해놓고 수집된 데이터로부터 학습을 진행하는 것을 말하고, 온라인 학습은 스트리밍 형태로 데이터를 계속 받으면서 능동적으로 학습하는 것을 말한다. 보통은 오프라인 학습을 다룬다. 온라인 학습은 IoT 등에서 추가로 발생하는 데이터 샘플을 가지고 점증적 학습을 수행한다.

<br>

- 결정록적 학습(deterministic learning)과 확률적 학습(stochastic learning)

결정론적 학습은 같은 데이터를 주면 똑같은 결과가 나오는 것이고, 확률적 학습은 같은 데이터라도 확률 분포를 사용하여 다른 모델이 만들어질 수 있는 것을 말한다. RBM/DBN이 확률적 학습에 해당된다.

<br>

- 분별 모델(discriminative models)와 생성 모델(generative models)

분별 모델은 부류 예측에만 관심이 있다. 즉, x에 대한 타겟 y를 추정하는 P(y\|x)에 관심이 있지만, 생성 모델은 P(x) 또는 P(x\|y) 처럼 x에 관심을 두는 것을 말한다. 따라서 새로운 샘플을 생성할 수 있다. GAN/RBM이 이에 해당된다. 

[generative models](https://dkssud8150.github.io/posts/cs231n13/)