---
title:    "[데브코스] 5주차 - OpenCV Color image processing "
author:
  name: JaeHo YooN
  link: https://github.com/dkssud8150
date: 2022-03-17 13:01:00 +0800
categories: [Classlog, devcourse]
tags: [devcourse, OpenCV ]
toc: True
comments: True
image:
  src: /assets/img/dev/week6/day1/gaussian.png
  width: 800
  height: 500
---

<br>

# 컬러 영상 처리의 기초

## 컬러 영상의 픽셀 값 참조

- OpenCV에서 컬러 영상 표현 방법
    - 빨강,초록, 파랑 색 성분을 256단계로 표현
    - opencv에서는 RGB순서가 아니라 **BGR**순서임

- OpenCV에서 컬러 영상 다루기

```cpp
Mat img1 = imread("lenna.bmp",IMREAD_COLOR);
Mat img2(rows,cols, CV_8UC3); // 3 channels

Mat img3 = imread("lenna.bmp",IMREAD_GRAYSCALE);
Mat img4;
cvtColor(img3,img4,COLOR_GRAY2BGR); // 눈으로 보기에는 동일하게 회색으로 나오게 된다. 이 때는 B=G=R 값이 같기 때문이다. 그러므로 1픽셀당 3byte를 차지하고 있다.

circle(src,Point(200,200), 100, Scalar(255,0,0),3); // grayscale이므로 밝기가 된다. 그래서 색이 아닌 밝기가 255
circle(dst,Point(200,200), 100, Scalar(255,0,0),3); // truecolor이므로 bgr순서의 스칼라값이 된다. 그래서 파란색
```

<br>

```cpp
Mat src = imread("lenna.bmp");

Mat dst = 255 - src; // 이렇게 하면 파란색으로 된다.
```

<img src="/assets\img\dev\week6\day1\colorconverterbefore.png">

이 결과는 올바르지 않다. 이 코드는 `Mat dst = Scalar(255,0,0,0) -src;`로 인식되므로 blue성분만 처리된다.

<br>

<br>

따라서 아래와 같이 3채널로 지정해줘야 반전이 된다.

```cpp
Mat dst = Scalar(255,255,255) - src; 
```

<img src="/assets\img\dev\week6\day1\colorconverter.png">

<br>

반전을 직접 구현하면 다음과 같다.

```cpp
Mat dst(src.rows, src.cols, CV_8UC3);

for (int y = 0; dst.rows; y++) {
    for (int x = 0; x < dst.cols; x++) {
        Vec3b& p1 = src.at<Vec3b>(y, x);
        Vec3b& p2 = dst.at<Vec3b>(y, x);
        p2[0] = 255 - p1[0]; //Blue
        p2[1] = 255 - p1[1]; //Green
        p2[2] = 255 - p1[2]; //Red
    }
}
```

여기서 중요한 것은 원래는 uchar이었던 자료형대신 `Vec3b` 자료형을 사용해야 한다. 전체 구현

```cpp
/* 1번째 방법 */
Vec3b& p1 = src.at<Vec3b>(y, x);
Vec3b& p2 = dst.at<Vec3b>(y, x);
p2[0] = 255 - p1[0]; //Blue
p2[1] = 255 - p1[1]; //Green
p2[2] = 255 - p1[2]; //Red

/* 2번째 방법 */
Vec3b& p1 = src.at<Vec3b>(y, x);
Vec3b& p2 = dst.at<Vec3b>(y, x);
p2 = Vec3b(255, 255, 255) - p1;

/* 3번째 방법 */
dst.at<Vec3b>(y, x) = Vec3b(255, 255, 255) - src.at<Vec3b>(y, x);
```

이 3가지 방법은 다 동일하게 동작한다.