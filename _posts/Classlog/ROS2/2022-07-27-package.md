---
title:    " [ROS2 프로그래밍] ROS 패키지 설계 (C++) "
author:
  name: JaeHo YooN
  link: https://github.com/dkssud8150
date: 2022-07-27 00:23:00 +0800
categories: [Classlog, ROS2]
tags: [ROS2]
toc: True
comments: True
--- 

&nbsp;

# ROS 패키지 제작

- [034 ROS2 패키지 설계 (C++)](https://cafe.naver.com/openrt/24798)
- [035 토픽 프로그래밍 (C++)](https://cafe.naver.com/openrt/24802)

## ROS 패키지 설계

<img src="/assets/img/ros2/package/package_configure.png">

목적별로 나누어 노드 단위의 프로그램을 작성하고, 노드와 노드간의 데이터 통신을 설계해야 한다. 이번 예제 패키지는 토픽, 서비스, 액션으로 구성하고자 한다. 

총 4개의 노드로 구성되며, 각 노드에서는 1개 이상의 토픽 퍼블리셔, 토픽 서브스크라이브, 서비스 서버, 서비스 클라이언트, 액션 서버, 액션 클라이언트가 존재한다. 중앙에 있는 노드는 다른 노드들과의 연동을 해야 하므로 가장 핵심적인 역할이다.

각각의 노드, 토픽, 서비스, 액션은 고유의 이름을 가지고 있다.

- `argument` : *arithmetic_argument* **토픽** 이름으로 현재 시간과 변수 a,b를 **퍼블리시**한다.
- `operator` : *arithmetic_operator* **서비스** 이름으로 calculator 노드에게 연산자(+-*/)를 **서비스** 요청값으로 보낸다.
- `calculator`
    - **토픽**이 생성된 시간과 변수 a,b를 *arithmetic_argument* 이름의 토픽을 **서브스크라이브**한다.
    - 받은 변수 a,b와 operator 노드로부터 요청값으로 받은 연산자를 통해 **계산**하고(a 연산자 b), operator 노드에게 결괏값을 *arithmetic_operator* 이름으로 **서비스 응답값**을 보낸다.
    - checker 노드로부터 **액션 목표값**(① action goal)을 받은 후부터 저장된 변수(a,b,연산자)를 가지고 연산한 값을 합한다. 그리고 연산이 끝난 계산식을 *arithmetic_checker* 이름으로 **액션 피드백**(② action feedback)을 checker 노드로 보낸다. 연산값의 합이 액션 목표값을 넘기면 최종 연산 합계를 *arithmetic_checker* 이름으로 **액션 결괏값**(③ action result)을 checker 노드로 보낸다.
- `checker` : 연산값의 합계의 **한계치**를 *arithmetic_checker* **액션** 이름으로 **액션** 목표값으로 **전달**한다.

&nbsp;

&nbsp;

## ROS 패키지 설정

🔥 주의 : 아래 파일들은 코드를 설명하기 위해서만 보고, 추후 git clone을 수행할 예정이므로 패키지를 직접 생성하지 않기를 바란다. 만약 패키지를 동일한 이름으로 생성할 경우 빌드에 문제가 생기므로, 다른 이름으로 생성하여 커스터마이징하거나, clone한 것을 사용하길 바란다.

&nbsp;

- package.xml

```xml
<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>

<!-- ROS2 패키지 설정파일의 package format이 세번째 버전이므로 3 -->
<package format="3">
  <!-- 패키지 이름 -->
  <name>topic_service_action_rclcpp_example</name>
  <version>0.2.0</version>

  <!-- 설명 -->
  <description>ROS 2 rclcpp example package for the topic, service, action</description> 
  <maintainer email="jhyoon@todo.todo">jhyoon</maintainer>
  <!-- 라이선스 -->
  <license>Apache License 2.0</license>
  <author email="passionvirus@gmail.com">Pyo</author>
  <author email="routiful@gmail.com">Darby Lim</author>

  <!-- 빌드툴 : ament_cmake -->
  <buildtool_depend>ament_cmake</buildtool_depend>

  <!-- dependency -->
  <!-- ros2에서 사용하는 cpp툴 -->
  <depend>rclcpp</depend>
  <!-- cpp툴에서 action 사용하기 위함 -->
  <depend>rclcpp_action</depend>
  <!-- 토픽,서비스,액션 인터페이스 사용하는 패키지 -->
  <depend>msg_srv_action_interface_example</depend>

  <!-- 사용하고자 하는 Lint 패키지, 테스트 코드를 위한 의존성 패키지 -->
  <test_depend>ament_lint_auto</test_depend>
  <test_depend>ament_lint_common</test_depend>

  <export>
    <!-- build type : ament_cmake -->
    <build_type>ament_cmake</build_type>
  </export>
</package>
```

&nbsp;

- CMakeLists.txt

CMakelist에는 크게 cmake 설정, 의존성 명시, 빌드, 설치, 테스트, ament package 매크로 설정으로 구성되어 있다.

```cpp
# Set minimum required version of cmake, project name and compile options
cmake_minimum_required(VERSION 3.5)

# project name
project(topic_service_action_rclcpp_example)

# C언어의 버전을 명시하지 않으면 C99를 기본으로 사용
if(NOT CMAKE_C_STANDARD)
  set(CMAKE_C_STANDARD 99)
endif()

# C++의 버전을 명시하지 않으면 C++ 14를 기본으로 사용
if(NOT CMAKE_CXX_STANDARD)
  set(CMAKE_CXX_STANDARD 14)
endif()

# GNU를 기본으로 사용하지만, Clang 컴파일러를 사용할 수도 있다.
if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
  add_compile_options(-Wall -Wextra -Wpedantic)
endif()

# Find dependencies
# REQUIRED : 패키지를 찾고, 없으면 에러가 나도록 하는 옵션
find_package(ament_cmake REQUIRED)
find_package(rclcpp REQUIRED)
find_package(msg_srv_action_interface_example REQUIRED)
find_package(rclcpp_action REQUIRED)

# header 파일을 가져오기 위한 디렉토리
include_directories(include)

# Build
# 실제로 실행하는 파일 (node_name file_directory)
add_executable(argument src/arithmetic/argument.cpp)
# 프로그램 실행을 위해 필요한 의존성 패키지
ament_target_dependencies(argument
  msg_srv_action_interface_example
  rclcpp
)

add_executable(calculator src/calculator/main.cpp src/calculator/calculator.cpp)
# calculator에서는 action도 진행되기에 의존성 패키지에 추가
ament_target_dependencies(calculator
  msg_srv_action_interface_example
  rclcpp
  rclcpp_action
)

add_executable(checker src/checker/main.cpp src/checker/checker.cpp)
ament_target_dependencies(checker
  msg_srv_action_interface_example
  rclcpp
  rclcpp_action
)

add_executable(operator src/arithmetic/operator.cpp)
ament_target_dependencies(operator
  msg_srv_action_interface_example
  rclcpp
)

# Install
install(TARGETS
  argument
  calculator
  checker
  operator
  DESTINATION lib/${PROJECT_NAME}
)

# 여기서 볼 수 있듯 launch 와 param은 share 폴더 아래에 저장해야 한다.
install(DIRECTORY launch param
  DESTINATION share/${PROJECT_NAME}
)

# Test
# test시 필요한 의존성 패키지들, 추후 test시 colcon test 를 통해 사용 가능
# ament_lint_auto_find_test_dependenices를 통해 cpplint라는 코드 스타일을 점검해주는 패키지를 사용
if(BUILD_TESTING)
  find_package(ament_lint_auto REQUIRED)
  ament_lint_auto_find_test_dependencies()
endif()

# Macro for ament package
# ament 패키지를 위한 매크로 함수를 적어주어야 함
ament_package()
```

&nbsp;

&nbsp;

## 코드 다운로드 및 빌드

`source ~/robot_ws/install/local_setup.bash`는 ~/.bashrc에 없으면 추가하고, 있으면 추가하지 않아도 된다.

```bash
$ cd ~/robot_ws/src
$ git clone https://github.com/robotpilot/ros2-seminar-examples.git
$ cd ~/robot_ws && colcon build --symlink-install
Starting >>> msg_srv_action_interface_example
Starting >>> logging_rclpy_example
Finished <<< logging_rclpy_example [1.26s]
Starting >>> my_first_ros_rclcpp_pkg
Finished <<< my_first_ros_rclcpp_pkg [13.8s]
Starting >>> my_first_ros_rclpy_pkg
...

$ echo 'source ~/robot_ws/install/local_setup.bash' >> ~/.bashrc
$ source ~/.bashrc

$ . ~/robot_ws/install/local_setup.bash
```

`. ~/robot_ws/install/local_setup.bash` 를 하지 않으면 패키지를 찾지 못한다는 에러가 뜨니 주의하자.

&nbsp;

빌드가 끝나고, 문제가 없다면 `~/robot_ws/install/topic_service_action_rclcpp_example` 폴더 안에 우리가 작성한 ROS 인터페이스를 사용하기 위한 파일들이 저장될 것이다.

```bash
$ ls ~/robot_ws/install
COLCON_IGNORE             logging_rclpy_example             rqt_example          tf2_rclpy_example
local_setup.bash          msg_srv_action_interface_example  setup.bash           time_rclcpp_example
local_setup.ps1           my_first_ros_rclcpp_pkg           setup.ps1            time_rclpy_example
local_setup.sh            my_first_ros_rclpy_pkg            setup.sh             topic_service_action_rclcpp_example
_local_setup_util_ps1.py  rclcpp_tutorial                   setup.zsh            topic_service_action_rclpy_example
_local_setup_util_sh.py   rclpy_tutorial                    testbot_description
local_setup.zsh           ros2env                           tf2_rclcpp_example


$ ls ~/robot_ws/install/topic_service_action_rclcpp_example/lib/topic_service_action_rclcpp_example/
argument    calculator  checker     operator

$ ls ~/robot_ws/install/topic_service_action_rclcpp_example/share/topic_service_action_rclcpp_example/
cmake/            launch/           local_setup.sh    package.dsv       package.xml
environment/      local_setup.bash  local_setup.zsh   package.ps1       package.zsh
hook/             local_setup.dsv   package.bash      package.sh        param/
```

이와 같이 argument, operator, calculator, checker와 같은 실행 스크립트가 생성되었다. 그리고 share 폴더 안에는 launch폴더와 param 폴더가 생성되었고, 각 폴더 안에는 arithmetic.launch.py와 arithmetic_config.yaml가 위치한다.

```bash
$ ls ~/robot_ws/install/topic_service_action_rclcpp_example/share/topic_service_action_rclcpp_example/launch/
arithmetic.launch.py

$ ls ~/robot_ws/install/topic_service_action_rclcpp_example/share/topic_service_action_rclcpp_example/param/
arithmetic_config.yaml
```

&nbsp;

&nbsp;

## 실행

- calculator 노드 실행

이 노드는 토픽 서브스크라이버, 서비스 서버, 액션 서버 역할을 수행한다.

```bash
$ ros2 run topic_service_action_rclcpp_example calculator
[INFO]: Run calculator
```

실행했지만, 아직 받는 토픽이나 서비스, 액션이 없으므로 동작이 되지 않는다.

&nbsp;

- argument 노드 실행

이 노드는 토픽 퍼블리셔 역할을 한다. 이를 실행하면 퍼블리시하고 있는 argument a, argument b가 표시될 것이고, 이를 통해 calculator 노드에서는 argument a, argument b와 함께 수신 받은 시간 정보가 출력될 것이다.

```bash
$ ros2 run topic_service_action_rclcpp_example argument
[INFO]: Published argument_a 4.73
[INFO]: Published argument_b 7.43
[INFO]: Published argument_a 1.55
[INFO]: Published argument_b 6.38
[INFO]: Published argument_a 7.09
[INFO]: Published argument_b 5.89
[INFO]: Published argument_a 5.90
[INFO]: Published argument_b 8.21
```

```bash
ros2 run  topic_service_action_rclcpp_example calculator
[INFO]: Run calculator
[INFO]: Timestamp of the message: sec 1658859718 nanosec 500974826
[INFO]: Subscribed argument a: 4.73
[INFO]: Subscribed argument b: 7.43
[INFO]: Timestamp of the message: sec 1658859719 nanosec 500985640
[INFO]: Subscribed argument a: 1.55
[INFO]: Subscribed argument b: 6.38
[INFO]: Timestamp of the message: sec 1658859720 nanosec 501005719
[INFO]: Subscribed argument a: 7.09
[INFO]: Subscribed argument b: 5.89
[INFO]: Timestamp of the message: sec 1658859721 nanosec 500910222
[INFO]: Subscribed argument a: 5.90
[INFO]: Subscribed argument b: 8.21
[INFO]: Timestamp of the message: sec 1658859722 nanosec 501017918
[INFO]: Subscribed argument a: 2.57
[INFO]: Subscribed argument b: 8.50
[INFO]: Timestamp of the message: sec 1658859723 nanosec 500904549
[INFO]: Subscribed argument a: 4.43
[INFO]: Subscribed argument b: 4.86
```

&nbsp;

- operator 노드 실행

이 노드는 서비스 클라이언트 역할을 한다. calculator 노드에게 랜덤으로 선택한 연산자를 서비스 요청값으로 보내고, 연산된 결과값을 받아 터미널 창에 표시한다. 실제 계산식은 calculator 노드가 실행 중인 창에서 확인할 수 있다.

```bash
$ ros2 run topic_service_action_rclcpp_example operator
[INFO]: Result 13.79
Press Enter for next service call.
[INFO]: Result 9.57
Press Enter for next service call.
[INFO]: Result 0.30
Press Enter for next service call.
[INFO]: Result 0.71
Press Enter for next service call.
```

```bash
$ ros2 run topic_service_action_rclcpp_example calculator
[INFO]: 2.224688 + 7.350139 = 9.57483
[INFO]: 2.224688 / 7.350139 = 0.302673

[INFO]: Timestamp of the message: sec 1658859884 nanosec 500955814
[INFO]: Subscribed argument a: 5.25
[INFO]: Subscribed argument b: 7.38
[INFO]: 5.247090 / 7.383574 = 0.710644
[INFO]: 5.247090 / 7.383574 = 0.710644
```

Entor 키를 통해 서비스를 보낼 수 있다.

&nbsp;

- checker 노드 실행

마지막으로 이 노드는 먼저 연산값의 합계 한계치를 액션 목표값으로 calculator 노드에 전달한다. 이후 checker 노드는 calculator 노드에게 액션 피드백을 받는데, 그 피드백은 각 연산과 그 결과의 string타입이다. 지정한 연산값의 합계가 목표 합계를 넘기면 checker 노드는 액션 결과값으로 calculator 노드로부터 최종 연산 합계를 전달받는다.

```bash
$ ros2 run topic_service_action_rclcpp_example checker
goal_total_sum : 50
[INFO]: Action goal accepted.
[INFO]: Action feedback:
[INFO]:         5.247090 / 7.383574 = 0.710644

[INFO]: Action feedback:
[INFO]:         5.247090 / 7.383574 = 0.710644

[INFO]:         5.247090 / 7.383574 = 0.710644

[INFO]: Action feedback:
[INFO]:         5.247090 / 7.383574 = 0.710644

[INFO]:         5.247090 / 7.383574 = 0.710644

[INFO]:         5.247090 / 7.383574 = 0.710644

[INFO]: Action feedback:
[INFO]:         5.247090 / 7.383574 = 0.710644

[INFO]:         5.247090 / 7.383574 = 0.710644

[INFO]:         5.247090 / 7.383574 = 0.710644

[INFO]:         5.247090 / 7.383574 = 0.710644
```

```bash
$ ros2 run topic_service_action_rclcpp_example calculator
[INFO]:         5.247090 / 7.383574 = 0.710644

[INFO]:         5.247090 / 7.383574 = 0.710644

[INFO]:         5.247090 / 7.383574 = 0.710644

[INFO]:         5.247090 / 7.383574 = 0.710644

[INFO]:         5.247090 / 7.383574 = 0.710644

[INFO]:         5.247090 / 7.383574 = 0.710644

[INFO]:         5.247090 / 7.383574 = 0.710644

[INFO]:         5.247090 / 7.383574 = 0.710644

[INFO]:         5.247090 / 7.383574 = 0.710644
```

동일한 logging이 출력되는데, 이는 목표 합계를 넘겼을 때,  calculator 노드가 checker 노드에게 최종 연산 합계를 전달하기 때문이다. 합계의 한계치는 기본으로 50으로 설정되어 있다. 이를 수정하고자 한다면 checker 노드를 실행시킬 때 실행 인자로 `-g 100` 이라 입력하면 GOAL_TOTAL_SUM  이라는 합계 한계치 인자가 100으로 할당된다.

```bash
ros2 run topic_service_action_rclcpp_example checker -g 100
```

&nbsp;

- launch 파일 실행

launch 파일을 통해 argument 노드와 calculator 노드를 한번에 실행시킬 수 있다. launch파일은 `arithmetic.launch.py` 파일이다.

```bash
ros2 launch topic_service_action_rclcpp_example arithmetic.launch.py
```

&nbsp;

&nbsp;

## ROS 토픽 뜯어보기

이제는 위의 패키지에서 토픽에 대해 더 자세히 뜯어보고자 한다. 

&nbsp;

토픽은 비동기식 단방향 메시지 송수신 방식으로 메시지를 발행하는 퍼블리셔와 메시지를 구독하는 서브스크라이버 간의 통신이다. 이는 1:1 통신을 기본으로 하지만, 1:N, N:1, N:N도 가능하다.

위에서 토픽은 argument 노드에서 calculator 노드로의 argument a, argument b, 토픽을 생성한 시간에 대한 메시지 전달이다.

<img src="/assets/img/ros2/package/topic.png">

&nbsp;

따라서 퍼블리셔와 서브스크라이버를 직접 작성해보고자 한다.

코드는 소스 파일과 헤더 파일이 존재하고, 각각 src 폴더와 include 폴더에 위치한다.

퍼블리셔
- topic_service_action_rclcpp_example/src/arithmetic/argument.cpp
- topic_service_action_rclcpp_example/include/arithmetic/argument.hpp

&nbsp;

서브스크라이버
- topic_service_action_rclcpp_example/src/arithmetic/argument.cpp
- topic_service_action_rclcpp_example/include/arithmetic/argument.hpp

&nbsp;

### 퍼블리셔

토픽 퍼블리셔 노드는 argument 노드이다.

1. Node 설정
2. QoS 설정
3. create_publisher 설정 (timer 설정)
4. 퍼블리시 함수 작성

&nbsp;

- 헤더 파일

```cpp
#ifndef ARITHMETIC__ARGUMENT_HPP_
#define ARITHMETIC__ARGUMENT_HPP_

// 시간을 다루는 라이브러리
#include <chrono>

// 동적 메모리를 다루는 라이브러리
#include <memory>

// 문자열을 다루는 라이브러리
#include <string>

// 서로다른 도메인을 다루는 라이브러리
#include <utility>

// rclcpp API를 담고 있는 rclcpp 헤더파일
#include "rclcpp/rclcpp.hpp"

// 만든 인터페이스를 담고 있는 헤더파일
#include "msg_srv_action_interface_example/msg/arithmetic_argument.hpp"

// rclcpp의 Node 클래스를 상속받는 Argument 클래스
class Argument : public rclcpp::Node
{
public:
  using ArithmeticArgument = msg_srv_action_interface_example::msg::ArithmeticArgument;

  // Argument 클래스의 생성자는 rclcpp의 NodeOptions를 인자로 받는다. NodeOptions에는 context, arguments, intra process communication, parameter, allocator와 같은 Node 생성을 위한 다양한 옵션이 존재
  explicit Argument(const rclcpp::NodeOptions & node_options = rclcpp::NodeOptions());
  virtual ~Argument();

private:
  void publish_random_arithmetic_arguments();
  void update_parameter();

  // 토픽 메시지에 담을 랜덤 변수의 범위
  float min_random_num_;
  float max_random_num_;

  // publisher와 timerbase 멤버변수가 선언되어 있다.
  rclcpp::Publisher<ArithmeticArgument>::SharedPtr arithmetic_argument_publisher_;
  rclcpp::TimerBase::SharedPtr timer_;
  rclcpp::Subscription<rcl_interfaces::msg::ParameterEvent>::SharedPtr parameter_event_sub_;
  rclcpp::AsyncParametersClient::SharedPtr parameters_client_;
};
#endif  // ARITHMETIC__ARGUMENT_HPP_
```

&nbsp;

- 소스 파일

```cpp
// C언어 표준 인풋 아웃풋 라이브러리
#include <cstdio>
#include <memory>
#include <string>
#include <utility>

// 랜덤 숫자 생성 라이브러리
#include <random>

#include "rclcpp/rclcpp.hpp"

/// 프로그램 실행시 넘겨받은 인자를 다루는 ROS2 라이브러리
#include "rcutils/cmdline_parser.h"

// 위에서 생성한 argument 헤더 파일
#include "arithmetic/argument.hpp"

using namespace std::chrono_literals;

// Argument 클래스, 부모 클래스인 rclcpp:Node를 선언해주었는데, 첫번째 인자에는 노드 이름을, 두번째 인자에는 노드 옵션 변수를 명시한다.
Argument::Argument(const rclcpp::NodeOptions & node_options)
: Node("argument", node_options),
  min_random_num_(0.0),
  max_random_num_(0.0)
{
  // QoS는 QoS 라이브러리를 이용하여 depth를 10으로 한다. 
  this->declare_parameter("qos_depth", 10);
  int8_t qos_depth = this->get_parameter("qos_depth").get_value<int8_t>();

  // 랜덤값 중 최소값로 0설정
  this->declare_parameter("min_random_num", 0.0);
  min_random_num_ = this->get_parameter("min_random_num").get_value<float>();

  // 랜덤값 중 최대값로 9설정
  this->declare_parameter("max_random_num", 9.0);
  max_random_num_ = this->get_parameter("max_random_num").get_value<float>();

  this->update_parameter();

  /*
  - History 옵션: KeepLast(depth : 10)
  - Reliability 옵션: reliable
  - Durability 옵션: volatile
  */
  const auto QOS_RKL10V =
    rclcpp::QoS(rclcpp::KeepLast(qos_depth)).reliable().durability_volatile();

  // QoS는 publisher를 초기화할 때 두번째 인자로 들어가고, 첫번째 인자는 메시지 통신에 사용될 토픽명
  arithmetic_argument_publisher_ =
    this->create_publisher<ArithmeticArgument>("arithmetic_argument", QOS_RKL10V);

  // 1초당 1번씩 publisher_random_arithmetic_arguments 멤버함수가 호출하도록 설정
  timer_ =
    this->create_wall_timer(1s, std::bind(&Argument::publish_random_arithmetic_arguments, this));
}

Argument::~Argument()
{
}

// timer에 의해 1초당 1번씩 호출
void Argument::publish_random_arithmetic_arguments()
{
  std::random_device rd;
  std::mt19937 gen(rd());

  // ROS2 파라미터를 통해 얻은 숫자가 min(0) 과 max(9) 사이의 랜덤한 값으로 숫자를 생성
  std::uniform_real_distribution<float> distribution(min_random_num_, max_random_num_);

  // msg_srv_action_interface_example 패키지에 있는 msg 인터페이스를 선언
  msg_srv_action_interface_example::msg::ArithmeticArgument msg;

  // time-stamp
  msg.stamp = this->now();

  // argument a
  msg.argument_a = distribution(gen);

  // argument b
  msg.argument_b = distribution(gen);

  // 토픽 발행
  arithmetic_argument_publisher_->publish(msg);

  // logging
  RCLCPP_INFO(this->get_logger(), "Published argument_a %.2f", msg.argument_a);
  RCLCPP_INFO(this->get_logger(), "Published argument_b %.2f", msg.argument_b);
}


void Argument::update_parameter()
{
  parameters_client_ = std::make_shared<rclcpp::AsyncParametersClient>(this);
  while (!parameters_client_->wait_for_service(1s)) {
    if (!rclcpp::ok()) {
      RCLCPP_ERROR(this->get_logger(), "Interrupted while waiting for the service. Exiting.");
      return;
    }
    RCLCPP_INFO(this->get_logger(), "service not available, waiting again...");
  }

  auto param_event_callback =
    [this](const rcl_interfaces::msg::ParameterEvent::SharedPtr event) -> void
    {
      for (auto & changed_parameter : event->changed_parameters) {
        if (changed_parameter.name == "min_random_num") {
          auto value = rclcpp::Parameter::from_parameter_msg(changed_parameter).as_double();
          min_random_num_ = value;
        } else if (changed_parameter.name == "max_random_num") {
          auto value = rclcpp::Parameter::from_parameter_msg(changed_parameter).as_double();
          max_random_num_ = value;
        }
      }
    };

  parameter_event_sub_ = parameters_client_->on_parameter_event(param_event_callback);
}

// help
void print_help()
{
  printf("For argument node:\n");
  printf("node_name [-h]\n");
  printf("Options:\n");
  printf("\t-h Help           : Print this help function.\n");
}


int main(int argc, char * argv[])
{
  // cmdline_parser 라이브러리 함수를 사용하여, 만약 명령 인자에 -h 가 있을 경우 print_help 함수를 호출하고 종료
  if (rcutils_cli_option_exist(argv, argv + argc, "-h")) {
    print_help();
    return 0;
  }

  // 초기화
  rclcpp::init(argc, argv);
  
  // Argument 클래스를 인스턴스화
  auto argument = std::make_shared<Argument>();
  
  // publish_random_arithmetic_arguments 실행
  rclcpp::spin(argument);
  
  // ctrl+c와 같은 시그널을 통해 노드 종료를 종료
  rclcpp::shutdown();

  return 0;
}
```

파라미터와 관련된 부분은 추후 다루도록 한다.

&nbsp;

### 서브스크라이버

토픽 서브스크라이버 노드는 calculator 노드이다. calculator의 소스 코드는 토픽 서브스크라이버, 서비스 서버, 액션 서버를 모두 포함하고 있어서 매우 길어서 토픽 서브스크라이버와 관련된 부분만 살펴보도록 한다.

calculator 클래스는 토픽 퍼블리셔 노드와 마찬가지로 rclcpp::node를 상속하고, 생성자에서 calculator라는 노드 이름으로 초기화된다. 그리고 위에서와 동일하게 QoS를 생성한다.

서브스크라이버는 `create_subscription`을 통해 초기화되고, 해당 함수는 토픽명과 QoS, 콜백함수를 인자로 받는다. 첫번째, 두번째 인자는 Argument 클래스와 동일하게 넣고, 콜백함수는 std::bind가 아닌 **람다 표현식**을 사용했다. 콜백함수를 보면 인자를 통해 수신받은 메시지에 접근하여 멤버 변수에 저장한다.

&nbsp;

1. Node 설정
2. QoS 설정
3. create_subscription 설정
4. 서브스크라이브 함수 작성

&nbsp;

- 소스파일

```cpp
  // QoS 설정 - history : KeepLast, Reliability : reliable, Durability : volatile
  const auto QOS_RKL10V =
    rclcpp::QoS(rclcpp::KeepLast(qos_depth)).reliable().durability_volatile();
  
  // 서브스크라이버 초기화, [토픽명, QoS]
  arithmetic_argument_subscriber_ = this->create_subscription<ArithmeticArgument>(
    "arithmetic_argument",
    QOS_RKL10V,
    [this](const ArithmeticArgument::SharedPtr msg) -> void
    {
      argument_a_ = msg->argument_a;
      argument_b_ = msg->argument_b;
      
      // logging - timestamp
      RCLCPP_INFO(
        this->get_logger(),
        "Subscribed at: sec %ld nanosec %ld",
        msg->stamp.sec,
        msg->stamp.nanosec);
      
      // logging - argument a, argument b
      RCLCPP_INFO(this->get_logger(), "Subscribed argument a : %.2f", argument_a_);
      RCLCPP_INFO(this->get_logger(), "Subscribed argument b : %.2f", argument_b_);
    }
  );
```

&nbsp;

&nbsp;

### 실행

실행하기 전에 CMakeLists.txt를 확인해서 add_executable 태그에 알맞게 들어가있는지 확인한다.

```txt
add_executable(argument src/arithmetic/argument.cpp)
add_executable(calculator src/calculator/main.cpp src/calculator/calculator.cpp)
```

첫번째 인자는 실행명, 그 다음 인자부터는 실행할 소스파일이다.

&nbsp;

실행은 `run`과 `launch` 두가지 방식이 있다.

```bash
$ ros2 run topic_service_action_rclcpp_example calculator
```

```bash
$ ros2 run topic_service_action_rclcpp_example argument
```

&nbsp;

```bash
$ ros2 launch topic_service_action_rclcpp_example arithmetic.launch.py
```

&nbsp;

두 방법 모두 동작하는 것은 동일하다.

&nbsp;