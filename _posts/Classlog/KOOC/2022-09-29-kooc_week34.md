---
title:    "[KOOC] 3,4주차 - Naive Bayes Classifier, logistic regression "
author:
  name: JaeHo YooN
  link: https://github.com/dkssud8150
date: 2022-09-29 00:40:00 +0800
categories: [Classlog, kooc]
tags: [kooc]
toc: true
comments: true
math: true
---

# Chapter 3. Motivation and Basics

- 목차

1. optimal classification
  - optimal predictor
  - concept of Bayes risk
  - concept of desicion boundary
2. Naive Bayes Classifier
  - what is classifier?
  - Bayesian version of linear classifier
  - naive assumption
3. naive classifier of text mining
  - bag-of-words


&nbsp;

&nbsp;

## 3-1. Decision Boundary

<img src="/assets/img/kooc/week34/optimal_classification.png">

optimal predictor 이란 이때까지 해왔던 f(X), 즉 $ \hat{f} $ 이 실제 Y와 같지 않을 확률이 최소가 되는 것을 f* 라는 것이다. 즉 우리가 가정한 값이 틀릴 확률이 최소가 되도록 하고자 한다. 이는 우리가 가정한 값이 정답일 확률이 최대가 되도록 한다는 것과 동일하다.

&nbsp;

<img src="/assets/img/kooc/week34/bayes_risk.png">

여기 점선과, 실선 총 4개의 값에 대한 그래프가 있다고 해보자. 이 때, 특정 X에 대해 점선은 점선끼리 더해서 1이 되어야 할 것이고, 실선은 실선끼리 더해서 1이 되어야 할 것이다. 이 둘 중 어느 것이 더 나은 것인지에 대한 측정을 해보아야 한다.4개의 선들이 모두 만나는 지점을 Xm이라 했을 때, 이 Xm보다 조금 앞인 Xn의 위치에서 보면 점선의 경우 초록색과 빨간색이 차이가 별로 크지 않다. 그러나 실선의 경우 점선보다는 다소 크다. 즉, 점선의 경우 명확하게 맞는지 틀린지를 구분하게 해주지 못한다는 뜻이다. Xm의 앞부분을 보면 초록색이 true라 판단하므로 빨간색 아래의 영역은 error에 해당된다. 그래서 점선의 빨간색 아랫부분과 실선의 빨간색 아랫부분의 차이가 두 모델의 차이이자 Bayes Risk라 불리는 값이 된다.

따라서 Bayes optimal classifier 라는 것은 Bayes risk라는 값의 크기를 줄이는 최적화를 수행하는 과정을 나타낸다.

&nbsp;

<img src="/assets/img/kooc/week34/optimal_classifier.png">

이 때, P(Y = y \| X = x ) 를 prior 정보를 조금 더 활용할 수 있도록 Bayes theorem을 통해 변환할 수 있다. Prior 정보를 알아낼 때는 MLE나 MAP 등의 방법으로 데이터셋에서 추출하여 얻을 수 있다. 그리고 class conditional density = P(X = x \| Y = y) 는 Y를 먼저 특정한 후, 그곳에서 x가 나올 확률을 구할 수 있다. 그러나 이러한 방식은 x의 feature가 1개 이상이고, 서로 상호적이라면 density를 추정하기 어려울 것이다. 

&nbsp;

## 3-2. Naive Bayes Classifier

따라서, 이러한 상호적인 관계를 무시하겠다는 것이 Naive Bayes Classifier이다. 각각의 feature들이 독립적이라는 가정하에 확률을 구해 추정한다.

<img src="/assets/img/kooc/week34/weather_dataset.png">

지난 번에 배웠던 이 데이터를 가지고, 함수를 최적화해보자. 각 x의 feature인 x1,x2,x3,x4,x5,x6가 있고, label인 y=yes가 존재한다. 이 때, prior는 y에 대해서 구하는 것이므로 yes에 대한 prior는 3/4가 된다. 즉, prior를 구하기 위해서 필요한 파라미터는 k-1(이 때 k=2), 1개이다. 그 후, P(X=x\|Y=y) 를 구해야 하는데, 이를 구하기 위해서 고려해야할 파라미터의 개수는 각 feature마다 2가지의 선택지만 존재한다고 해도 64개의 값이 더해지면 1이 되어야 한다는 특성으로 이해 63개의 값만 구하면 된다. 그리고 y의 값도 고려해줘야 하므로 (2^d - 1)^k 개의 파라미터가 필요하다. 2개의 선택지만 가정한다 해도 (64-1)*2 = 126 개의 파라미터가 필요해진다. 

&nbsp;

우리가 직접 모델을 추정하기 위해서는 (2^d - 1)^k 를 잘 해결해야 간편하게 모델을 추정할 수 있다. 이를 위해 conditional independence, 즉 각 feature 별 독립을 가정하여 연산을 줄이고자 한다. 

<img src="/assets/img/kooc/week34/marginal_independence.png">

예를 들어, 상사인 commander가 한명 있고, 2명의 officer가 있다고 할 때, 만약 A가 명령을 듣지 못한다해도 B가 수행하는 행동에 따라서 행동할 수 있을 것이다. 이는 독립적이지 않다는 의미가 된다. 그러나 만약 B가 어떻게 행동하든지 상사의 명령을 무조건 들을 수 있어서 따르게 된다면 B의 행동에 영향을 받지 않는다. 이럴 때는 독립적이게 된다. marginal independence라는 것은 상사가 어떻게 말하든 듣지 않고, 행동을 하는 상황을 일컫는다.

&nbsp;

<img src="/assets/img/kooc/week34/conditional_independence.png">

아까의 데이터셋으로 돌아와 P(X=x\|Y=y)를 구하기 위해서는 (2^d -1)^k 개의 파라미터가 필요했다. 그러나 우리가 독립적이라는 것을 가정하게 되면 $ P(X=x|Y=y) = P(X)P(Y) $ 로 계산이 가능하다. 그렇게 되면, 개별 feature들 간 곱셈으로 변하게 되어, (2-1)dk 개의 파라미터 수로 줄어든다.

&nbsp;

최종적으로 Naive Bayes Classifier 에 의해 구해진 f는 다음과 같다.

$$ f_{NB}(x) = argmax_{Y=y} P(Y=y) \prod_{1 \leq i \leq d} P(X_i = x_i | Y = y) $$

&nbsp;

naive bayes classifier는 생성하기 쉽다. 확률만 MLE, MAP를 통해 잘 구해줄 수 있다면 구하기 쉽다. 그러나 그만큼 문제점은 많이 존재한다. 각 feature간이 독립적이라는 것 자체가 부정확한 가정이며, 값이 존재하지 않은 feature가 있다면 0으로 수렴하는 값이 추론될 수 있게 될 것이다.

&nbsp;

&nbsp;

# Chapter 4. Logistic Regression
