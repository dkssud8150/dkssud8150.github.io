<!DOCTYPE html><html lang="en" data-mode="light" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="[데브코스] 5주차 - Computer Vision abstract and image analysis about memory allocation" /><meta name="author" content="JaeHo YooN" /><meta property="og:locale" content="en" /><meta name="description" content="Do focus on developing ‘your ability’ rather than waste time on making you famous." /><meta property="og:description" content="Do focus on developing ‘your ability’ rather than waste time on making you famous." /><link rel="canonical" href="https://dkssud8150.github.io/posts/comvision/" /><meta property="og:url" content="https://dkssud8150.github.io/posts/comvision/" /><meta property="og:site_name" content="JaeHo Yoon" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-03-14T14:34:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[데브코스] 5주차 - Computer Vision abstract and image analysis about memory allocation" /><meta name="twitter:site" content="@" /><meta name="twitter:creator" content="@JaeHo YooN" /><meta name="google-site-verification" content="znvuGsQGYxMZPBslC4XG6doCYao6Y-fWibfGlcaMHH8" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"JaeHo YooN"},"dateModified":"2022-03-14T14:34:00+09:00","datePublished":"2022-03-14T14:34:00+09:00","description":"Do focus on developing ‘your ability’ rather than waste time on making you famous.","headline":"[데브코스] 5주차 - Computer Vision abstract and image analysis about memory allocation","mainEntityOfPage":{"@type":"WebPage","@id":"https://dkssud8150.github.io/posts/comvision/"},"url":"https://dkssud8150.github.io/posts/comvision/"}</script><title>[데브코스] 5주차 - Computer Vision abstract and image analysis about memory allocation | JaeHo Yoon</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="JaeHo Yoon"><meta name="application-name" content="JaeHo Yoon"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/shin_chan.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">JaeHo Yoon</a></div><div class="site-subtitle font-italic">Mamba Mentality</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fab fa-angellist ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/dkssud8150" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['hoya58150','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="https://www.notion.so/18490713817d403696812c57d0abe730" aria-label="notion" target="_blank" rel="noopener"> <i class="fab fa-battle-net"></i> </a> <a href="https://www.linkedin.com/in/jaeho-yoon-90b62b230" aria-label="linkedin" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href="https://www.instagram.com/jai_ho8150/" aria-label="instagram" target="_blank" rel="noopener"> <i class="fab fa-instagram"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>[데브코스] 5주차 - Computer Vision abstract and image analysis about memory allocation </span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"> <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 800 500'%3E%3C/svg%3E" data-src="/assets/img/dev/week5/day1/main.png" class="preview-img bg" alt="Preview Image" width="800" height="500" data-proofer-ignore><h1 data-toc-skip>[데브코스] 5주차 - Computer Vision abstract and image analysis about memory allocation</h1><div class="post-meta text-muted"><div> By <em> <a href="https://github.com/dkssud8150">JaeHo YooN</a> </em></div><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6611243953442169" crossorigin="anonymous"></script><div class="d-flex"><div> <span> Posted <em class="timeago" date="2022-03-14 14:34:00 +0900" data-toggle="tooltip" data-placement="bottom" title="Mon, Mar 14, 2022, 2:34 PM +0900" >Mar 14, 2022</em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="6712 words"> <em>37 min</em> read</span></div></div></div><div class="post-content"><p><br /></p><h1 id="개요">개요</h1><h2 id="컴퓨터-비전computer-vision이란">컴퓨터 비전(computer vision)이란? <a href="#컴퓨터-비전computer-vision이란" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>컴퓨터를 이용하여 정지 영상 또는 동영상으로부터 의미 있는 정보를 추출하는 방법을 연구하는 학문이다.</p><p><br /></p><h2 id="컴퓨터-비전과-영상-처리image-processing">컴퓨터 비전과 영상 처리(image processing) <a href="#컴퓨터-비전과-영상-처리image-processing" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>영상(image)란 사진이나 비디오 등을 다 포함한 것을 말한다. 동영상을 말할 때는 video라고 한다. 영상 처리는 영상을 입력으로 받아 화질을 개선하겆나 크롭핑하여 다시 영상을 출력하는 것을 말하고, 거기서 객체를 인식하는 등의 추가 작업을 컴퓨터 비전이라 한다. 그러나 뜻이 거의 동일하기에 동일시 하는 곳도 많다.</p><p><br /></p><h2 id="컴퓨터-비전의-역사">컴퓨터 비전의 역사 <a href="#컴퓨터-비전의-역사" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>1960년 MIT The summer vision project 연구가 컴퓨터 비전의 시초이다. 이 때, 위성으로부터 전송 받은 달 표면 사진의 화질을 복원했다. 현재는 2012년에 딥러닝 모델인 AlexNet이 나오게 되면서 딥러닝이 기하급수적으로 발전되었다.</p><p><br /></p><ul><li>컴퓨터 비전 vs 휴먼 비전</ul><p>사람은 주변의 영향을 많이 받기 떄문에 정확한 그곳의 색상을 보기 보다는 주변의 상황과 함께 판단해서 어디가 어두운지, 밝은지를 판단한다. 그러나 컴퓨터는 해당 위치의 픽셀을 추출해서 판단하기 때문에 객관적으로 판단할 수 있을 것이다.</p><p><br /></p><h1 id="컴퓨터-비전의-응용-분야">컴퓨터 비전의 응용 분야</h1><h2 id="영상의-화질-개선">영상의 화질 개선 <a href="#영상의-화질-개선" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>카메라로 찍은 사진을 더욱 선명하게 만들거나 색상을 원하는 형태로 변경하는 등의 작업을 한다. RAW 영상의 변환, 사진앱의 필터, 잡은 제거, HDR, 초해상도 등을 할 수 있다.</p><p><img data-src="/assets/img/dev/week5/day1/superresolution.jpeg" data-proofer-ignore></p><h2 id="내용-기반-영상-검색-content-based-imagevideo-retrieval">내용 기반 영상 검색 (content-based image/video retrieval) <a href="#내용-기반-영상-검색-content-based-imagevideo-retrieval" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>영상에 존재하는 사람, 사물, 색상 정보 등을 인식하여 유사한 영상을 자동으로 찾아주는 시스템이다. 이를 비주얼 검색(visual search)라고도 한다.</p><p><img data-src="/assets/img/dev/week5/day1/retrieval.jpg" data-proofer-ignore></p><h2 id="얼굴-검출-및-인식">얼굴 검출 및 인식 <a href="#얼굴-검출-및-인식" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>얼굴 검출(face detection): 영상에서 얼굴의 위치와 크기를 찾는 기법이다.</p><p>얼굴 인식(face recognition): 검출된 얼굴이 누구인지를 판단하는 기술이다.</p><ul><li>미세한 표정 변화도 감지한다.<li>조명 변화, 안경 착용, 헤어 스타일 변화에 의해 정확도가 낮아질 수는 있다.</ul><p><img data-src="/assets/img/dev/week5/day1/facerecog.jpg" data-proofer-ignore></p><h2 id="의료-영상-처리">의료 영상 처리 <a href="#의료-영상-처리" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>x-ray, CT에 사용되는 영상처리이다. 영상의 화질 개선, 영상의 자동 분석을 할 수 있다.</p><p><br /></p><h2 id="광학-문자-인식">광학 문자 인식 <a href="#광학-문자-인식" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>영상에 있는 텍스트를 인식한다. 이를 OCR(optical character recognition)이라 한다. 번역, 자동차 번호판 인식 등을 할 수 있다.</p><p><br /></p><h2 id="마커-인식">마커 인식 <a href="#마커-인식" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>정해진 형태의 마커를 인식하여 숨겨진 정보를 추출할 수 있다. 2D 바코드, QR 코드를 인식할 수 있다.</p><p><br /></p><h2 id="영상-기반-증강-현실">영상 기반 증강 현실 <a href="#영상-기반-증강-현실" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>카메라로 특정 사진을 가리키면 관련된 정보가 증강되어 나타나는 기술이다. 마커 기반과 비 마커 기반으로 나뉜다.</p><p><br /></p><h2 id="머신-비전machine-vision">머신 비전(machine vision) <a href="#머신-비전machine-vision" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>주로 산업계에서 제품의 위치 확인, 측정, 불량 검사 등을 위해 사용되는 영상 기반 기술이다. 공장의 자동화를 촉진시킬 수 있다. 빠른 처리 시간, 높은 정확도, 객관성이 장점이다. 카메라, 렍, 조명, 필터, 영상 보드, 영상 처리 소프트웨어 등으로 구성되어 있다.</p><p><br /></p><h2 id="인공지능-서비스">인공지능 서비스 <a href="#인공지능-서비스" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>입력 영상을 객체와 배경으로 분할하여 객체와 배경을 인식하고 그 후 상황을 인식할 수 있다. 이를 바탕으로 로봇과 자동차의 행동을 지시할 수 있다.</p><p>computer vision + sensor fusion + deep learning 이라 할 수 있다. 이를 상용화한 것이 amazon go\/ 구글,테슬라의 자율 주행 자동차가 있다.</p><p><br /></p><p><br /></p><h1 id="영상-데이터의-구조와-특징">영상 데이터의 구조와 특징</h1><h2 id="영상image이란">영상(image)이란? <a href="#영상image이란" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>픽셀이 바둑판 모양의 격자에 나열되어 있는 형태로 2차원 행렬 형태를 가지고 있다. 이 때 픽셀이랑 영상의 기본 단위이다.</p><p><img data-src="/assets/img/dev/week5/day1/pixel.png" data-proofer-ignore></p><p><br /></p><h2 id="grayscale-image">Grayscale Image <a href="#grayscale-image" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>영상 데이터에는 크게 2가지 종류가 있는데, 하나는 grayscale, 즉 흑백 사진처럼 색상 정보가없이 오직 밝기 정보만으로 구성된 영상을 말한다. 밝기 정보를 256단계로 표현한다.</p><p><img data-src="/assets/img/dev/week5/day1/grayscale.jpg" data-proofer-ignore></p><ul><li>그레이스케일 영상의 픽셀값 표현</ul><p><img data-src="/assets/img/dev/week5/day1/grayscalebar.jpeg" data-proofer-ignore></p><p>그레일스케일 영상에서 하나의 픽셀은 0~255 사이의 정수 값을 가진다. 0이 검정색, 255가 흰색을 나타낸다.</p><p>grayscale level: 그레일 스케일의 픽셀이 가질 수 있는 범위를 나타내는 것으로 [0,255] 또는 [0,256) 이라 표현할 수 있다. 즉 []는 포함, ()는 미포함이라 할 수 있다.</p><p><br /></p><p>이를 c/c++에서는 unsigned char로 표현할 수 있다. 이는 1byte 공간을 사용한다.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">BYTE</span><span class="p">;</span>     <span class="c1">// windows</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="kt">uint8_t</span><span class="p">;</span>  <span class="c1">// linux</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">uchar</span><span class="p">;</span>    <span class="c1">// opencv</span>
</pre></table></code></div></div><p>이 unsigned char을 그냥 사용하지 않고, 편의성과 통일성을 위해 typedef를 사용하여 쓴다. 각각 사용하는 곳이 다르다.</p><p><br /></p><ul><li>픽셀 값 분포의 예</ul><p><img data-src="/assets/img/dev/week5/day1/cameraman.jpg" data-proofer-ignore></p><p>이는 영상 처리에서 유명한 사진인 <code class="language-plaintext highlighter-rouge">camera man</code> 사진이다. 이 때, 픽셀 값을 보면 어두운 값이 0에 가깝고, 밝을수록 255에 가까울 것이다. 그리고 자세히 보게 되면 우리는 구분하지 못하지만, 값이 10~20정도 차이가 나는 것을 볼 수 있다.</p><p><br /></p><h2 id="truecolor-image">truecolor image <a href="#truecolor-image" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>컬러 사진처럼 다양한 색상을 표현할 수 있는 영상을 말한다. R/G/B 색 성분을 각 256 단계로 표현한다.</p><p><img data-src="/assets/img/dev/week5/day1/truecolor.png" data-proofer-ignore></p><p><br /></p><ul><li>트루컬러 영상의 픽셀값 표현</ul><p>R/G/B 색 성분의 크기를 각각 0.~255 범위의 정수로 표현한다. 0은 없는 상태, 255는 가득있는 상태를 말한다.</p><p><img data-src="/assets/img/dev/week5/day1/truecolorcircle.png" data-proofer-ignore></p><p><br /></p><p>이를 c/c++에서는 unsigned char로 자료형 3개 있는 배열 또는 구조체로 표현한다. 따라서 3byte를 차지하게 된다.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">RGB</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">R</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">G</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">B</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p><br /></p><ul><li>픽셀 값 분포의 예</ul><p><img data-src="/assets/img/dev/week5/day1/truecolorpixelvalue.png" data-proofer-ignore></p><p>이 사진을 보면, 각각의 픽셀이 3개의 값을 가지고 있다. 코의 부분에서는 빨간색이 높게 나오고 있고, 오른쪽부분은 파란색이 높게 나오고 있다.</p><p><br /></p><h2 id="영상에서-사용되는-좌표계">영상에서 사용되는 좌표계 <a href="#영상에서-사용되는-좌표계" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p><img data-src="/assets/img/dev/week5/day1/imageaxis.png" data-proofer-ignore></p><p>영상에서 사용되는 좌표계는 좌측 상단을 0,0으로 기준을 잡는다. 그리고 0,0부터 시작하므로 크기가 (w,h)의 이미지, 즉 <code class="language-plaintext highlighter-rouge">w-by-h image</code>라 할 때, 마지막은 (w,h)가 아닌 (w-1,h-1)의 좌표를 가진다. 이를 2차원 행렬로 표현하기도 한다. M행, N열을 가진 M x N 행렬이 있다고 할 때, 이를 <code class="language-plaintext highlighter-rouge">m-by-n matrix</code>라 한다.</p><p><img data-src="/assets/img/dev/week5/day1/imagematrix.png" data-proofer-ignore></p><p>여기서 주의해야 할 것은 영상에서는 w, 즉 가로를 먼저 작성하지만, 행렬로 표현할 때는 행, 즉 세로를 먼저 작성한다. 그래서 640x480 이미지라 하면 영상으로 표현되어 있는지 행렬로 표현되어 있는지를 알아야 한다. 이것이 틀릴 경우 출력이 이상하게 나오거나 오류가 날 것이다.</p><p><br /></p><p><br /></p><h1 id="영상-데이터의-표현-방법">영상 데이터의 표현 방법</h1><p>이미지는 대체로 2차원 행렬로 이루어져 있기에 2차원 배열을 생성하면 될 것이다.</p><h2 id="정적-2차원-배열-생성">정적 2차원 배열 생성 <a href="#정적-2차원-배열-생성" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">a</span><span class="p">[</span><span class="mi">480</span><span class="p">][</span><span class="mi">640</span><span class="p">]</span> <span class="p">{};</span>
</pre></table></code></div></div><ul><li>unsigned char: 1바이트 사용(0~255 사이의 정수 표현)<li>2차원 배열 전체 크기만큼의 메모리 공간이 연속적으로 할당된다. (640x480 = 307200 bytes)<li>단점:<ul><li>배열의 크기를 미리 알고 있어야 한다. -&gt; 다양한 크기의 영상을 표현하기에 부적절하다.<li>stack 영역에 메모리를 할당하기에 대략 1MB까지만 할당이 가능하다.<li>=&gt; 그래서 방법은 잘 사용하지 않고, 동적 메모리 할당을 사용한다.</ul></ul><p><img data-src="/assets/img/dev/week5/day1/2matrix.png" data-proofer-ignore></p><p><br /></p><h2 id="동적-2차원-배열-생성">동적 2차원 배열 생성 <a href="#동적-2차원-배열-생성" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>
<span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="mi">640</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">480</span><span class="p">;</span>

<span class="kt">unsigned</span> <span class="kt">char</span><span class="o">**</span> <span class="n">p</span><span class="p">;</span>
<span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">h</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="p">{};</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>행 단위로만 연속된 메모리 공간이 보장된다.<li>프로그램 동작 중 다양한 크기의 영상을 생성할 수 있다.<li>heap 영역에 메모리를 할당하므로서 x86의 경우 2GB까지 할당이 가능하고, x64의 경우 8TB까지 가능하다.</ul><p><br /></p><h3 id="코드-자세히-분석">코드 자세히 분석 <a href="#코드-자세히-분석" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>1. unsigned char** p;
2. p = new unsigned char*[h];
3. for (int i = 0; i &lt; h; i++) {
4.     p[i] = new unsigned char[w] {};
}
</pre></table></code></div></div><p>1.unsigned char 2차원 포인터 p를 선언 -&gt; local 영역에 로컬 변수 형태로 포인터 변수가 생성된다.</p><p><br /></p><p>2.new 연산자를 통해서 unsigned char 포인터 타입을 h개 만큼 할당 -&gt; h개만큼의 포인터 변수가 생성되고 그 위치를 p가 가리키도록 할당된다. 그렇게 되면 <code class="language-plaintext highlighter-rouge">p[0]~p[h-1]</code>까지 접근할 수 있게 된다.</p><p><img data-src="/assets/img/dev/week5/day1/pointp.png" data-proofer-ignore></p><p><br /></p><p>3.w개만큼의 unsigned char 메모리 공간을 h만큼 할당하게 된다.</p><p><img data-src="/assets/img/dev/week5/day1/pointph.png" data-proofer-ignore></p><p><br /></p><ul><li>동적 2차원 배열 원소 접근 방법</ul><p>할당을 한 후에는 2중 for문을 사용해서 각각의 픽셀값에 접근할 수 있다.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="c1">// 2차원 배열 p의 모든 원소 값을 10씩 증가</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">h</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// y 좌표</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">w</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// x 좌표</span>
        <span class="n">p</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>좌측 상단부터 오른쪽으로 간 후 다음 줄 -&gt; 오른쪽 -&gt; 다음줄 … 순서로 된다.</p><p><br /></p><h2 id="동적-2차원-배열-메모리-해제">동적 2차원 배열 메모리 해제 <a href="#동적-2차원-배열-메모리-해제" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>동적으로 할당한 2차원 배열은 사용이 끝난 후에는 반드시 해제를 해야한다. 이때 delete를 사용한다. 동적 2차원 배열 생성의 역순으로 해제해야 한다.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">h</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="k">delete</span><span class="p">[]</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>이 때, delete에 <code class="language-plaintext highlighter-rouge">[]</code>를 반드시 같이 사용해야 한다. 그리고 2차원 각각의 행에 대한 메모리를 해제하고, p의 포인터에 대해 한 번 더 해제해야 한다.</p><p><br /></p><h2 id="대용량-1차원-메모리-할당-후-영상-데이터-저장">대용량 1차원 메모리 할당 후 영상 데이터 저장 <a href="#대용량-1차원-메모리-할당-후-영상-데이터-저장" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>그러나 영상 데이터를 2차원이 아닌 1차원으로 메모리를 할당하여 저장할 수도 있다.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="p">[</span><span class="n">w</span> <span class="o">*</span> <span class="n">h</span><span class="p">]</span> <span class="p">{};</span>
<span class="p">...</span>

<span class="k">delete</span><span class="p">[]</span> <span class="n">data</span><span class="p">;</span> <span class="c1">// 메모리 해제</span>
</pre></table></code></div></div><p>10x10 영상데이터를 저장한다고 했을 때, 10*10=100개의 unsigned char 메모리 공간을 할당하고 모든 픽셀 데이터를 저장한다. 순서는 위와 같이 좌측 상단부터 다음 줄 -&gt; 오른쪽 -&gt; 다음줄 … 순서로 저장한다.</p><ul><li>특정 좌표 (x,y) 위치 픽셀 값 참조</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&amp;</span> <span class="n">p1</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">data</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="n">w</span> <span class="o">+</span> <span class="n">x</span><span class="p">);</span>
</pre></table></code></div></div><p>포인터 연산을 사용해서 w는 영상의 가로 크기, data는 시작 좌표를 의미한다.</p><p><br /></p><h2 id="간단한-형태의-영상-데이터-저장-클래스-생성">간단한 형태의 영상 데이터 저장 클래스 생성 <a href="#간단한-형태의-영상-데이터-저장-클래스-생성" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">MyImage</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">MyImage</span><span class="p">()</span> <span class="o">:</span> <span class="n">w</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">h</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">data</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">// default, 즉 init</span>

    <span class="n">MyImage</span><span class="p">(</span><span class="kt">int</span> <span class="n">_w</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_h</span><span class="p">)</span> <span class="o">:</span> <span class="n">w</span><span class="p">(</span><span class="n">_w</span><span class="p">),</span> <span class="n">h</span><span class="p">(</span><span class="n">_h</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// w,h 두 개의 정수 값을 받는 생성자에서는 w,h를 초기화</span>
        <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="p">[</span><span class="n">w</span> <span class="o">*</span> <span class="n">h</span><span class="p">]</span> <span class="p">{};</span> <span class="c1">// new 연산자를 이용해서 데이터 공간을 메모리 할당, 그 시작 주소를 data가 가르키도록 했다.</span>
    <span class="p">}</span>

    <span class="o">~</span><span class="n">MyImage</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// 소멸자</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="k">delete</span><span class="p">[]</span> <span class="n">data</span><span class="p">;</span> <span class="c1">// 메모리 할당이 있었으면 그것을 삭제하도록</span>
    <span class="p">}</span>

    <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// at을 이용해서 (x,y) 좌표에 있는 픽셀값을 반환하도록 하는데, 참조(&amp;)로 반환하도록 해서 읽어올 뿐만 아니라 픽셀값을 설정할 수도 있도록 만듦</span>
        <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="n">data</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">w</span> <span class="o">+</span> <span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>

<span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">;</span> <span class="c1">// w: 영상 가로 크기, h: 영상 세로 크기</span>
    <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">data</span><span class="p">;</span> <span class="c1">// 픽셀 데이터를 저장하기 위해 동적 할당한 메모리 공간의 시작 주소를 가리킬 포인터 변수</span>
<span class="p">}</span>
</pre></table></code></div></div><p><br /></p><p><br /></p><h1 id="영상-파일의-형식과-특징">영상 파일의 형식과 특징</h1><h2 id="bmp-파일-구조">BMP 파일 구조 <a href="#bmp-파일-구조" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>비트맵(bitmap)</p><ul><li>비트(bit)들의 집합(map) -&gt; 픽셀의 집합<li>영상의 전체 크기에 해당하는 픽셀 정보를 그대로 저장한다.<ul><li>장점: 표현이 직관적이고 분석이 용이하다.<li>단점: 메모리 용량을 많이 차지한다. 영상의 확대/축소시 화질 손상이 심하다.</ul><li>사진, 포토샵<li>비트맵의 종류<ul><li>장치 의존 비트맵(DDB): 출력 장치(화면, 프린터 등)의 설정에 따라 다르게 표현된다.<li>장치 독립 비트맵(DIB): 출력 장치가 달라져도 항상 동일하게 출력된다. <strong>BMP 파일은 Windows 환경에서 비트맵을 DIB형태로 저장한 파일 포맷이다.</strong></ul></ul><p>벡터 그래픽스(vector graphics)</p><ul><li>점과 점을 연결해 수학적 원리로 그림을 그려 표현하는 방식<li>이미지 크기를 확대/축소해도 화질이 손상되지 않음<li>폰트, 일러스트레이터</ul><p><img data-src="/assets/img/dev/week5/day1/bitmapandvector.jpeg" data-proofer-ignore></p><p><br /></p><p>아래는 BMP 파일 구조를 나타낸 것이다.</p><p><img data-src="/assets/img/dev/week5/day1/bitmapstructure.png" data-proofer-ignore></p><p>1.비트맵 파일 헤더</p><p>이는 비트맵 파일에 대한 정보를 담고 있다.</p><p>파일 헤더의 구조체는 다음과 같다. WORD의 경우 2byte, DWORD는 4byte크기의 자료형이다. 그러므로 이는 전체 14 bytes로 표현되는 구조체다.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">tagBITMAPFILEHEADER</span> <span class="p">{</span>
    <span class="n">WORD</span>    <span class="n">bfType</span><span class="p">;</span>     <span class="c1">// 이 파일이 bmp파일인지 아닌지를 나타내는 지시자, 'B', 'M', 0x42/0x4D 와 같이 16진수로 기록이 된다.</span>
    <span class="n">DWORD</span>   <span class="n">bfsize</span><span class="p">;</span>     <span class="c1">// BMP 파일 크기를 4byte크기로 저장된다</span>
    <span class="n">WORD</span>    <span class="n">bfReserved1</span><span class="p">;</span><span class="c1">// 현재 사용되지 않는 플래그</span>
    <span class="n">WORD</span>    <span class="n">bfReserved2</span><span class="p">;</span><span class="c1">// 현재 사용되지 않는 플래그</span>
    <span class="n">DWORD</span>   <span class="n">bf0ffBits</span><span class="p">;</span>  <span class="c1">// 비트맵 비트까지의 오프셋으로 비트맵 파일 헤더로부터 픽셀 데이터가 있는 위치까지의 거리를 나타낸다.</span>
<span class="p">}</span> <span class="n">BITMAPFILEHEADER</span><span class="p">;</span>
</pre></table></code></div></div><p>2.비트맵 정보 헤더</p><p>여기서는 비트맵 영상에 대한 정보를 담고 있다.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">tagBITMAPINFOHEADER</span> <span class="p">{</span>
    <span class="n">DWORD</span>   <span class="n">biSize</span><span class="p">;</span>             <span class="c1">// BITMAPINFOHEADER 크기</span>
    <span class="n">LONG</span>    <span class="n">biWidth</span><span class="p">;</span>            <span class="c1">// 비트맵 가로 크기, 4bytes</span>
    <span class="n">LONG</span>    <span class="n">biHeight</span><span class="p">;</span>           <span class="c1">// 비트맵 세로 크기</span>
    <span class="n">WORD</span>    <span class="n">bitPlanes</span><span class="p">;</span>          <span class="c1">// 항상 1을 저장</span>
    <span class="n">WORD</span>    <span class="n">bitBitCount</span><span class="p">;</span>        <span class="c1">// 한 픽셀의 컬러를 표현하기 위해 사용되는 비트 수를 나타낸다. truecolor의 경우 24, grayscale의 경우 8을 가진다.</span>
    <span class="n">DWORD</span>   <span class="n">biCompression</span><span class="p">;</span>      <span class="c1">// BI_RGB, 대부분의 경우 0</span>
    <span class="n">DWORD</span>   <span class="n">biSizeImage</span><span class="p">;</span>        <span class="c1">// 대부분의 경우 0</span>
    <span class="n">LONG</span>    <span class="n">biXPelsPerMeter</span><span class="p">;</span>    <span class="c1">// 대부분의 경우 0</span>
    <span class="n">LONG</span>    <span class="n">biYPelsPerMeter</span><span class="p">;</span>    <span class="c1">// 대부분의 경우 0</span>
    <span class="n">DWORD</span>   <span class="n">biClrUsed</span><span class="p">;</span>          <span class="c1">// 대부분의 경우 0</span>
    <span class="n">DWORD</span>   <span class="n">biClrImportant</span><span class="p">;</span>     <span class="c1">// 대부분의 경우 0</span>
<span class="p">}</span> <span class="n">BITMAPINFOHEADER</span><span class="p">;</span>
</pre></table></code></div></div><p>3.색상 테이블/팔레트</p><p>여기서는 비트맵에서 사용되는 색상 정보를 담고 있다.</p><p>RGBQUAD는 4byte로 구성되어 있다.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">tagRGBQUAD</span> <span class="p">{</span>
    <span class="n">BYTE</span>    <span class="n">rgbBlue</span><span class="p">;</span>        <span class="c1">// Blue</span>
    <span class="n">BYTE</span>    <span class="n">rgbGreen</span><span class="p">;</span>       <span class="c1">// Green</span>
    <span class="n">BYTE</span>    <span class="n">rgbRed</span><span class="p">;</span>         <span class="c1">// Red</span>
    <span class="n">BYTE</span>    <span class="n">rgbReserved</span><span class="p">;</span>    <span class="c1">// 사용되지 않는 공간인 1, 이를 사용하는 이유는 4의 배수로 맞춰주기 위함이다. 이는 메모리를 조금 더 빠르게 사용할 수 있기 때문에 사용한다.</span>
<span class="p">}</span> <span class="n">RGBQUAD</span><span class="p">;</span>
</pre></table></code></div></div><p>이는 256컬러 이하의 비트맵에서만 존재한다. 그래서 grayscale 비트맵에서는 존재하고, truecolor 비트맵에서는 존재하지 않는다.</p><ul><li>그레일스케일 비트맵<ul><li>(0,0,0,0),(1,1,1,0)…,(255,255,255,0) 의 총 256개의 색상을 가진다.<li>전체 4 * 256 = 1024bytes의 색상 테이블을 가지고 있게 된다.</ul><li>트루컬러 비트맵<ul><li>이 색상 테이블을 가지지 않고 마지막 픽셀 데이터에 색상 정보를 저장한다.</ul></ul><p>4.픽셀 데이터</p><ul><li>그레이스케일 비트맵: RGBQUAD 배열에 이미 정의되어 있기 때문에 배열의 인덱스 값을 저장<li>트루컬러 비트맵: 색상 테이블이 없기 때문에 (B,G,R) 순서로 픽셀 값을 저장</ul><p>일반적으로 상하가 뒤집힌 상태로 저장된다. (<strong>bottom-up</strong>)</p><p>또한, 효율적인 데이터 관리를 위해 영상의 가로 크기를 4의 배수로 맞춰서 저장한다.</p><p>그레이스케일의 경우</p><p>4bytes x 3bytes</p><div class="table-wrapper"><table><thead><tr><th> <th> <th> <th> <tbody><tr><td>idx<td>idx<td>idx<td>0<tr><td>idx<td>idx<td>idx<td>0<tr><td>idx<td>idx<td>idx<td>0</table></div><p>트루컬러의 경우</p><p>12bytes x 3bytes</p><div class="table-wrapper"><table><thead><tr><th> <th> <th> <th> <th> <th> <th> <th> <th> <th> <th> <th> <tbody><tr><td>B<td>G<td>R<td>B<td>G<td>R<td>B<td>G<td>R<td>0<td>0<td>0<tr><td>B<td>G<td>R<td>B<td>G<td>R<td>B<td>G<td>R<td>0<td>0<td>0<tr><td>B<td>G<td>R<td>B<td>G<td>R<td>B<td>G<td>R<td>0<td>0<td>0</table></div><p><br /></p><p><br /></p><p><img data-src="/assets/img/dev/week5/day1/gray_4x4.png" width="400px" data-proofer-ignore></p><p>이러한 그레이스케일 파일이 있다고 하자. 이를 바이너리 편집기로 열면 아래와 같이 출력된다.</p><p><img data-src="/assets/img/dev/week5/day1/graybmp.png" width="50%" data-proofer-ignore> <img data-src="/assets/img/dev/week5/day1/graydesc.png" width="50%" data-proofer-ignore></p><p>맨 앞 줄의 숫자는 빼고, 그 다음부터 확인하면 된다. 오른쪽이 숫자들을 분석한 사진이다.</p><ul><li>bfType: bmp파일이므로 42, 4D<li>bfSize: bmp파일의 크기<li>biSize: 28 00 00 00, 16진수이므로 32+8이므로 bitmapinfoheader의 크기는 40byte<li>biWidth, biHeight: 가로,세로가 4x4<li>biBitCount: 1픽셀을 표현하기 위해 8bit 즉, 2^8=256가지의 색상을 나타낼 수 있다.<li>그레이스케일이므로 biClrImportant에서 infoheader가 끝나고 rgbquad를 4x256 = 1024byte만큼의 색상 테이블이 나타나게 된다. 0부터 FF(255)까지 나타나있다.<li>파란색: 실제 픽셀값에 대한 정보를 역순으로 나타내게 됨. 즉 FF FF FF FF는 맨 아래, 흰색을 나타낸다. 근데 중요한 것은 FF가 스케일값 자체를 나타내는 것이 아니라 <strong>색상 테이블 중에서 255번째에 있는 색상을 가지고 있다</strong>는 것을 나타낸다.</ul><p><br /></p><p><img data-src="/assets/img/dev/week5/day1/color_4x4.png" width="400px" data-proofer-ignore></p><p><img data-src="/assets/img/dev/week5/day1/colordesc.png" data-proofer-ignore></p><ul><li>bfType: bmp파일이므로 42, 4D<li>biSize: 32+8=40byte<li>biWidth,biHeight: 4x4<li>biBitCount: 1=16 + 8 == 24bit, 즉 1픽셀당 3bytes<li>트루컬러이므로 색상 테이블이 없다.<li>[80(B) 80(G) 80(R)] 는 16진수이므로 [128, 128, 128] 즉 회색<li>FF 00 00: Blue 가 4개<li>00 FF 00: Green 가 4개<li>00 00 FF: Red 가 4개</ul><p><br /></p><p><br /></p><p>이 bmp파일을 구체화시켜서 보고자 한다.</p><ol><li>visual studio 에서 새 프로젝트 생성 -&gt; window 데스크톱 애플리케이션<li>이름은 각자 작성하고, <code class="language-plaintext highlighter-rouge">솔루션 및 프로젝트~</code> 를 체크한다.</ol><p>생성하게 되면 기본적인 소스코드를 만들어준다. 여기서 간단하게 코드를 살펴보면</p><ul><li>mwinmain : 클래스를 등록<li>initinstance: createwindow라는 함수를 이용해서 실제 윈도우를 만들고, showwindow를 사용해서 화면에 보여준다.<li>myregisterclass: 기본적인 윈도우 스타일에 대한 정보를 기록하고 있다. 이를 registerclassexw라는 것으로 보낸다. 이는 운영체제에 이러한 윈도우를 만들 것이라는 것을 등록한다.<li>winproc: 윈도우 메시지를 처리하는 함수다.<ul><li>wm_command: 어떤 메뉴를 선택했을 때 처리하는 케이스<li>wm_paint: 화면에 어떤 그림을 그릴 때 사용하는 케이스<li>wm_destroy: 프로그램이 종료될 때 실행되는 케이스</ul><li>about: 도움말 대화상자</ul><p>솔루션 빌드를 하고, 디버깅하지 않고 시작을 누르면 창이 하나 생성되는 것을 볼 수 있다.</p><p><br /></p><p>그래서 이 WM_COMMAND가 끝나는 부분에 왼쪽 마우스가 눌렸을 때에 대한 메시지를 처리하도록 하고자 한다.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
</pre><td class="rouge-code"><pre><span class="cp"># include &lt;stdio.h&gt;     // 파일에 대한 처리를 위해 맨 위에 # include &lt;stdio.h&gt; 를 추가
</span>
<span class="k">case</span> <span class="n">WM_LBUTTONDOWN</span><span class="p">:</span>
<span class="p">{</span>
    <span class="kt">FILE</span><span class="o">*</span> <span class="n">fp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">fopen_s</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fp</span><span class="p">,</span> <span class="s">"cat.bmp"</span><span class="p">,</span> <span class="s">"rb"</span><span class="p">);</span> <span class="c1">// 현재 폴더에 있는 cat.bmp 열기</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fp</span><span class="p">)</span>
        <span class="k">break</span><span class="p">;</span>

    <span class="n">BITMAPFILEHEADER</span> <span class="n">bmfh</span><span class="p">;</span> <span class="c1">// fileheader에 대한 정보를 담을 구조체 선언</span>
    <span class="n">BITMAPINFOHEADER</span> <span class="n">bmih</span><span class="p">;</span> <span class="c1">// infoheader에 대한 정보를 담을 구조체 선언</span>

    <span class="n">fread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bmfh</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">BITMAPFILEHEADER</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span> <span class="c1">// 불러온 파일에서 bitmapfileheader 크기만큼을 불러와서 bmfh에 저장</span>
    <span class="n">fread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bmih</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">BITMAPINFOHEADER</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span> <span class="c1">// 불러온 파일에서 bitmapfileheader 크기만큼을 불러와서 bifh에 저장</span>

    <span class="n">LONG</span> <span class="n">nWidth</span> <span class="o">=</span> <span class="n">bmih</span><span class="p">.</span><span class="n">biWidth</span><span class="p">;</span>         <span class="c1">// bitmapinfoheader중에서 가로 추출</span>
    <span class="n">LONG</span> <span class="n">nHeight</span> <span class="o">=</span> <span class="n">bmih</span><span class="p">.</span><span class="n">biHeight</span><span class="p">;</span>       <span class="c1">// bitmapinfoheader중에서 세로 추출</span>
    <span class="n">WORD</span> <span class="n">nBitCount</span> <span class="o">=</span> <span class="n">bmih</span><span class="p">.</span><span class="n">biBitCount</span><span class="p">;</span>   <span class="c1">// bitmapinfoheader중에서 각각의 픽셀이 몇 비트로 표현되고 있는가에 대한 정보 추출</span>

    <span class="n">DWORD</span> <span class="n">dwWidthStep</span> <span class="o">=</span> <span class="p">(</span><span class="n">DWORD</span><span class="p">)((</span><span class="n">nWidth</span> <span class="o">*</span> <span class="n">nBitCount</span> <span class="o">/</span> <span class="mi">8</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">3</span><span class="p">);</span> <span class="c1">// 하나의 행을 표현하기 위해 필요한 메모리 크기를 계산하는 것, 가로 크기 * 각 byte 크기를 한 후, `+ 3) &amp; ~3)은 이 값보다 같거나 큰 4의 배수값을 구하는 방법이다.</span>
    <span class="n">DWORD</span> <span class="n">dwSizeImage</span> <span class="o">=</span> <span class="n">nHeight</span> <span class="o">*</span> <span class="n">dwWidthStep</span><span class="p">;</span> <span class="c1">// 영상의 세로크기와 위의 값을 곱하면 전체 픽셀 데이터를 저장하기 위해 필요한 메모리 공간의 크기를 구할 수 있다.</span>

    <span class="n">DWORD</span> <span class="n">dwDibSize</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nBitCount</span> <span class="o">==</span> <span class="mi">24</span><span class="p">)</span>    <span class="c1">// 트루 컬러의 경우</span>
        <span class="n">dwDibSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">BITMAPINFOHEADER</span><span class="p">)</span> <span class="o">+</span> <span class="n">dwSizeImage</span><span class="p">;</span> <span class="c1">// 전체 Dibsize라고 해서 infoheader와 전체 영상 데이터의 크기를 더한다.</span>
    <span class="k">else</span>    <span class="c1">// 그레이스케일의 경우</span>
        <span class="n">dwDibSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">BITMAPINFOHEADER</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">RGBQUAD</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">nBitCount</span><span class="p">)</span> <span class="o">+</span> <span class="n">dwSizeImage</span><span class="p">;</span> <span class="c1">// 색상 테이블의 크기까지 추가해서 전체 Dibsize를 구할 수 있다.</span>

    <span class="n">BYTE</span><span class="o">*</span> <span class="n">pDib</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BYTE</span><span class="p">[</span><span class="n">dwDibSize</span><span class="p">];</span> <span class="c1">// 메모리 공간을 동적 할당</span>

    <span class="c1">// fseek 함수를 이용해서 파일의 맨 처음에서 비트맵 파일 헤더 크기만큼 이동하므로 비트맵 정보 헤더 위치로부터 DIB크기(dwDibSize)만큼을 파일로부터 읽는다.</span>
    <span class="n">fseek</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">BITMAPFILEHEADER</span><span class="p">),</span> <span class="n">SEEK_SET</span><span class="p">);</span> 
    
    <span class="c1">// pDib 메모리에는 비트맵 정보 헤더와 색상테이블(팔레트), 픽셀 데이터 정보가 저장된다.</span>
    <span class="n">fread</span><span class="p">(</span><span class="n">pDib</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">BYTE</span><span class="p">),</span> <span class="n">dwDibSize</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>

    <span class="n">LPVOID</span> <span class="n">lpvBits</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nBitCount</span> <span class="o">==</span> <span class="mi">24</span><span class="p">)</span> <span class="c1">// 두 가지를 따로 계산하는 이유는 이 두개의 포인터 값을 이용해서 setDIBitsToDevice라는 win32함수를 사용해서 bitmap을 나타낼 때 사용되기 때문이다.</span>
        <span class="n">lpvBits</span> <span class="o">=</span> <span class="n">pDib</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">BITMAPINFOHEADER</span><span class="p">);</span> <span class="c1">// 실제 픽셀 데이터가 나타나는 주소값을 계산</span>
    <span class="k">else</span>
        <span class="n">lpvBits</span> <span class="o">=</span> <span class="n">pDib</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">BITMAPINFOHEADER</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">RGBQUAD</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">nBitCount</span><span class="p">);</span>

    <span class="n">HDC</span> <span class="n">hdc</span> <span class="o">=</span> <span class="n">GetDC</span><span class="p">(</span><span class="n">hWnd</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">LOWORD</span><span class="p">(</span><span class="n">lParam</span><span class="p">);</span> <span class="c1">// winRroc에 있는 인자값에 있는 것으로 실제 마우스가 클릭된 x좌표를 파싱하는 코드</span>
    <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">HIWORD</span><span class="p">(</span><span class="n">lParam</span><span class="p">);</span> <span class="c1">// winRroc에 있는 인자값에 있는 것으로 실제 마우스가 클릭된 y좌표를 파싱하는 코드</span>
    <span class="o">::</span><span class="n">SetDIBitsToDevice</span><span class="p">(</span><span class="n">hdc</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">nWidth</span><span class="p">,</span> <span class="n">nHeight</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nHeight</span><span class="p">,</span> <span class="n">lpvBits</span><span class="p">,</span>
        <span class="p">(</span><span class="n">BITMAPINFO</span><span class="o">*</span><span class="p">)</span><span class="n">pDib</span><span class="p">,</span> <span class="n">DIB_RGB_COLORS</span><span class="p">);</span> <span class="c1">// 출력하는데 필요한 정보들을 전달</span>
    <span class="n">ReleaseDC</span><span class="p">(</span><span class="n">hWnd</span><span class="p">,</span> <span class="n">hdc</span><span class="p">);</span>

    <span class="k">delete</span><span class="p">[]</span> <span class="n">pDib</span><span class="p">;</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">break</span><span class="p">;</span>
</pre></table></code></div></div><p><br /></p><h2 id="bmpjpggifpng-파일-형식의-특징">BMP/JPG/GIF/PNG 파일 형식의 특징 <a href="#bmpjpggifpng-파일-형식의-특징" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><ol><li>BMP<ul><li>픽셀 데이터를 압축하지 않고 그대로 저장 -&gt; 파일 용량이 큰 편<li>파일 구조가 단순해서 별도의 라이브러리 도움 없이 파일 입출력 프로그래밍이 가능<li>파일의 크기가 중요하지 않은 연산의 경우 이를 사용한다.</ul><li>JPG/JPEG<ul><li>주로 사진과 같은 컬러 영상을 저장<li>손실 압축(lossy compression)<li>압축률이 좋아서 파일 용량이 크게 감소 -&gt; 디지털 카메라 사진 포맷으로 주로 사용됨<li>정밀한 영상 처리나 컴퓨터 비전에서는 픽셀 값이 조금만 바뀌어도 성능이 차이가 나서 선호는 하지 않는다.</ul><li>GIF<ul><li>256 색상 이하의 영상을 저장 -&gt; 일반 사진을 저장 시 화질 열화가 심하다.<li>무손실 압축(lossless compression)<li>움직히는 GIF 지원<li>영상 처리에서는 잘 사용하지 않는다.</ul><li>PNG<ul><li>Portable Network Graphics<li>무손실 압축 (컬러 영상도 무손실 압축)<li>알파 채널(투명도/불투명도)를 지원한다.<li>파일의 크기가 중요하지 않을 때 사용한다.</ul></ol><p><br /></p><h2 id="영상-데이터-크기-분석">영상 데이터 크기 분석 <a href="#영상-데이터-크기-분석" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>그레이스케일 영상: (가로 크기) x (세로 크기) bytes<ul><li>(512x512) 의 경우 512x512=26211bytes</ul><li>트루컬러 영상: (가로 크기) x (세로 크기) x 3 bytes<ul><li>FHD(1820x1080) 의 경우 1920x1080x3 = 6220800bytes<li>이를 30fps로 1분 재생하려면 6MB x 30fps = 180MB x 60sec = 1GB</ul></ul><div class="table-wrapper"><table><thead><tr><th> <th><img data-src="/assets/img/dev/week5/day1/lenna_gray.png" width="33%" data-proofer-ignore><th><img data-src="/assets/img/dev/week5/day1/sky.png" width="33%" data-proofer-ignore><th><img data-src="/assets/img/dev/week5/day1/tree.png" width="33%" data-proofer-ignore><tbody><tr><td>속성<td>521x512 Grayscale<td>1920x1080 Truecolor<td>1920x1080 Truecolor<tr><td>BMP<td>263,222<td>6,220,854<td>6,220,854<tr><td>PNG<td>167,488<td>2,730,645<td>4,081,084<tr><td>JPG(95%)<td>90.965<td>512,220<td>1,098,200<tr><td>JPG(80%)<td>37,923<td>213,879<td>542,790</table></div><p>bytes 변환하는 방법으로는 cv2::imwrite()함수를 사용하면 된다. 나는 그냥 python으로 구해보았다.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kn">from</span> <span class="n">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="n">name</span> <span class="o">=</span> <span class="s">'lenna_gray'</span>
<span class="n">filenames</span> <span class="o">=</span> <span class="p">[</span><span class="s">'./'</span> <span class="o">+</span> <span class="n">name</span><span class="o">+</span><span class="s">'.bmp'</span><span class="p">,</span> <span class="s">'./'</span><span class="o">+</span> <span class="n">name</span><span class="o">+</span><span class="s">'.png'</span><span class="p">,</span><span class="s">'./'</span><span class="o">+</span><span class="n">name</span><span class="o">+</span><span class="s">'_95p.jpg'</span><span class="p">,</span><span class="s">'./'</span><span class="o">+</span><span class="n">name</span><span class="o">+</span><span class="s">'_80p.jpg'</span><span class="p">]</span>

<span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">filenames</span><span class="p">:</span>
    <span class="n">file_size</span> <span class="o">=</span><span class="nc">Path</span><span class="p">(</span><span class="n">f</span><span class="p">).</span><span class="nf">stat</span><span class="p">().</span><span class="n">st_size</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s">'/'</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="s">" size is:"</span><span class="p">,</span> <span class="n">file_size</span><span class="p">,</span><span class="s">"bytes"</span><span class="p">)</span>
</pre></table></code></div></div><div class="language-markdown highlighter-rouge"><div class="code-header"> <span data-label-text="Markdown"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>lenna_gray.bmp  size is: 263222 bytes
lenna_gray.png  size is: 167488 bytes
lenna_gray_95p.jpg  size is: 90965 bytes
lenna_gray_80p.jpg  size is: 37923 bytes
</pre></table></code></div></div><p>lenna_gray.bmp 파일의 크기는 비트맵 크기 <code class="language-plaintext highlighter-rouge">14</code> + infoheader크기 <code class="language-plaintext highlighter-rouge">40</code> + 팔레트 크기 <code class="language-plaintext highlighter-rouge">1024</code> + 가로x세로 <code class="language-plaintext highlighter-rouge">512x512</code> = <code class="language-plaintext highlighter-rouge">263,222</code> 로 구할 수 있다.</p><p>sky.bmp나 tree.bmp의 경우는 14 + 40 + 1920x1080 = 6,220,854bytes 가 된다.</p><p>jpg의 경우 압축률을 정할 수 있다. 그래서 위의 경우 95%, 80%로 지정했다. 80%가 더 큰 압축률을 의미한다.</p><p>sky와 tree의 크기가 다른 이유는 픽셀값의 변화가 다소 작은 경우 압축이 더 많이 되기 때문에 sky가 크기가 더 작다. 이처럼 <strong>픽셀값의 변화가 작은 경우 저주파 성분이 강하다</strong>고 하고, <strong>변화가 큰 경우 고주파 성분이 강하다</strong>고 할 수 있다.</p><p><br /></p><p><br /></p></div><div class="post-tail-wrapper text-muted"><div style="text-align: left;"> <a href="http://hits.dwyl.com/dkssud8150.github.io/posts/comvision/" target="_blank"> <img data-src="http://hits.dwyl.com/dkssud8150.github.io/posts/comvision.svg" data-proofer-ignore> </a></div><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/classlog/'>Classlog</a>, <a href='/categories/devcourse/'>devcourse</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/computer-vision/" class="post-tag no-text-decoration" >computer-vision</a> <a href="/tags/devcourse/" class="post-tag no-text-decoration" >devcourse</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=[데브코스] 5주차 - Computer Vision abstract and image analysis about memory allocation - JaeHo Yoon&amp;url=https://dkssud8150.github.io/posts/comvision/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=[데브코스] 5주차 - Computer Vision abstract and image analysis about memory allocation - JaeHo Yoon&amp;u=https://dkssud8150.github.io/posts/comvision/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https://dkssud8150.github.io/posts/comvision/&amp;text=[데브코스] 5주차 - Computer Vision abstract and image analysis about memory allocation - JaeHo Yoon" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://dkssud8150.github.io/posts/comvision/" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6611243953442169" crossorigin="anonymous"></script></div><script src="https://utteranc.es/client.js" repo="dkssud8150/dkssud8150.github.io" issue-term="pathname" theme="github-light" crossorigin="anonymous" async> </script></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/gitpage/">[깃허브 프로필 꾸미기] github 프로필 만들기</a><li><a href="/posts/product/">[깃허브 프로필 꾸미기] productive box 만들기</a><li><a href="/posts/regex/">[데브코스] 2주차 - linux 기초(REGEX)</a><li><a href="/posts/Kfold/">KFold Cross Validation 과 StratifiedKFold</a><li><a href="/posts/cmake/">[데브코스] 17주차 - CMake OpenCV, Eigen, Pangolin install </a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/devcourse/">devcourse</a> <a class="post-tag" href="/tags/deeplearning/">deeplearning</a> <a class="post-tag" href="/tags/cs231n/">CS231N</a> <a class="post-tag" href="/tags/ros/">ros</a> <a class="post-tag" href="/tags/coding-test/">coding test</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/kooc/">kooc</a> <a class="post-tag" href="/tags/opencv/">OpenCV</a> <a class="post-tag" href="/tags/pytorch-tutorial/">pytorch tutorial</a> <a class="post-tag" href="/tags/autonomous-driving/">Autonomous Driving</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/start/"><div class="card-body"> <em class="timeago small" date="2022-02-14 13:00:00 +0900" >Feb 14, 2022</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[데브코스] 카테고리 설명 및 개요</h3><div class="text-muted small"><p> 데브코스라는 교육을 받으면서 배웠던 내용을 기재하고자 한다. 최대한 많은 내용을 담고 싶지만, 저작권으로 인해 적지 못하는 부분도 많을 것 같다. 원래는 노션에 기록하고 있었지만, 매번 블로그에 기재하던 것처럼 블로그에 업로드해야 계속 기록에 남기도 하고 다음 번에도 계속 볼 것 같다.</p></div></div></a></div><div class="card"> <a href="/posts/algorithm/"><div class="card-body"> <em class="timeago small" date="2022-02-15 13:00:00 +0900" >Feb 15, 2022</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[데브코스] 1주차 - 알고리즘 문제 풀기 (1)</h3><div class="text-muted small"><p> 코드에 대한 주석들은 추후에 달도록 하겠습니다. 현재는 블로그 정리만 하려고 올리는 것입니다. 자료구조와 알고리즘 자료구조 문자열 (str) “this is a string” 리스트 (list) [4,9,2,7] 사전 (dict) {‘a’:2, ‘bc’,:6} 순서쌍 (tuple), 집합 (set), … 해결할 문제에...</p></div></div></a></div><div class="card"> <a href="/posts/algorithm2/"><div class="card-body"> <em class="timeago small" date="2022-02-17 13:00:00 +0900" >Feb 17, 2022</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[데브코스] 1주차 - 알고리즘 문제 풀기 (2)</h3><div class="text-muted small"><p> 스택 (stack) 스택: 자료를 보관할 수 있는 선형 구조 x.isempty() : 스택이 비어있는지 판단한다. x.peek() : 스택에 가장 나중에 저장된 데이터 원소를 참조한다. x.size() x.push() x.pop() 단, 넣을 때는 한 쪽 끝에서 밀어 넣어야 하는 push 연산, 꺼낼 때는 같은 쪽에서 뽑아 ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/sensordriving/" class="btn btn-outline-primary" prompt="Older"><p>[데브코스] 4주차 - ROS Self-driving using sensors</p></a> <a href="/posts/opencvinstall/" class="btn btn-outline-primary" prompt="Newer"><p>[데브코스] 5주차 - OpenCV abstract and install</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://twitter.com/username">JaeHo YooN</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/devcourse/">devcourse</a> <a class="post-tag" href="/tags/deeplearning/">deeplearning</a> <a class="post-tag" href="/tags/cs231n/">CS231N</a> <a class="post-tag" href="/tags/ros/">ros</a> <a class="post-tag" href="/tags/coding-test/">coding test</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/kooc/">kooc</a> <a class="post-tag" href="/tags/opencv/">OpenCV</a> <a class="post-tag" href="/tags/pytorch-tutorial/">pytorch tutorial</a> <a class="post-tag" href="/tags/autonomous-driving/">Autonomous Driving</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-NC7MWHVXJE"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-NC7MWHVXJE'); }); </script>