<!DOCTYPE html><html lang="en" data-mode="light" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="[데브코스] 14주차 - DeepLearning Geometrical Distance Estimation" /><meta name="author" content="JaeHo YooN" /><meta property="og:locale" content="en" /><meta name="description" content="Do focus on developing ‘your ability’ rather than waste time on making you famous." /><meta property="og:description" content="Do focus on developing ‘your ability’ rather than waste time on making you famous." /><link rel="canonical" href="https://dkssud8150.github.io/posts/distanceestim/" /><meta property="og:url" content="https://dkssud8150.github.io/posts/distanceestim/" /><meta property="og:site_name" content="JaeHo Yoon" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-05-16T15:20:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[데브코스] 14주차 - DeepLearning Geometrical Distance Estimation" /><meta name="twitter:site" content="@" /><meta name="twitter:creator" content="@JaeHo YooN" /><meta name="google-site-verification" content="znvuGsQGYxMZPBslC4XG6doCYao6Y-fWibfGlcaMHH8" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"JaeHo YooN"},"dateModified":"2022-11-04T00:38:05+09:00","datePublished":"2022-05-16T15:20:00+09:00","description":"Do focus on developing ‘your ability’ rather than waste time on making you famous.","headline":"[데브코스] 14주차 - DeepLearning Geometrical Distance Estimation","mainEntityOfPage":{"@type":"WebPage","@id":"https://dkssud8150.github.io/posts/distanceestim/"},"url":"https://dkssud8150.github.io/posts/distanceestim/"}</script><title>[데브코스] 14주차 - DeepLearning Geometrical Distance Estimation | JaeHo Yoon</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="JaeHo Yoon"><meta name="application-name" content="JaeHo Yoon"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/shin_chan.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">JaeHo Yoon</a></div><div class="site-subtitle font-italic">Mamba Mentality</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fab fa-angellist ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/dkssud8150" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['hoya58150','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="https://www.notion.so/18490713817d403696812c57d0abe730" aria-label="notion" target="_blank" rel="noopener"> <i class="fab fa-battle-net"></i> </a> <a href="https://www.linkedin.com/in/jaeho-yoon-90b62b230" aria-label="linkedin" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href="https://www.instagram.com/jai_ho8150/" aria-label="instagram" target="_blank" rel="noopener"> <i class="fab fa-instagram"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>[데브코스] 14주차 - DeepLearning Geometrical Distance Estimation</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>[데브코스] 14주차 - DeepLearning Geometrical Distance Estimation</h1><div class="post-meta text-muted"><div> By <em> <a href="https://github.com/dkssud8150">JaeHo YooN</a> </em></div><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6611243953442169" crossorigin="anonymous"></script><div class="d-flex"><div> <span> Posted <em class="timeago" date="2022-05-16 15:20:00 +0900" data-toggle="tooltip" data-placement="bottom" title="Mon, May 16, 2022, 3:20 PM +0900" >May 16, 2022</em> </span> <span> Updated <em class="timeago" date="2022-11-04 00:38:05 +0900 " data-toggle="tooltip" data-placement="bottom" title="Fri, Nov 4, 2022, 12:38 AM +0900" >Nov 4, 2022</em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="6409 words"> <em>35 min</em> read</span></div></div></div><div class="post-content"><p><br /></p><p><a href="https://dkssud8150.github.io/posts/perception/">이전 글</a>에서 computer vision에서 활용하는 기하학적 방법으로 객체의 위치를 추정하는 방법을 배웠다.</p><p><br /></p><h1 id="geometrical-distance-estimation">Geometrical Distance Estimation</h1><p>이처럼 기하학적 방법으로 객체의 위치를 추정하는 방법들은 많이 존재한다. 그 첫번째 방법이 카메라의 투영(calibration)을 활용한 방법이다.</p><p><br /></p><h2 id="geometrical-method">Geometrical Method <a href="#geometrical-method" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>카메라와 대상 객체의 기하학적 조건을 활용한 방법으로 카메라의 설치 노이와 대상 객체가 3차원 공간에 존재할 때 Extrinsic calibration 정보를 활용한 방법이다.</p><p><br /></p><p><img data-src="/assets/img/dev/week12/day5/figure2.png" data-proofer-ignore></p><p>이는 camera와 차량의 위치 관계에 대한 그림이다. 카메라를 A에 장착하고, B차량을 촬영하면 B차량의 타이어 지점은 이미지에서 y1에 표현된다.</p><p>그러나 이 방법은 바닥이 평면을 이루어야 하고, 바닥과 광학축이 평행해야 한다는 조건이 존재했다.</p><p>삼각 비례식을 활용하여 객체의 실제 거리를 추정할 수 있다.</p><p>$ object:distance = \cfrac{focal:length * real:world’s:height:of:object}{image’s:height:of:object} $</p><p><br /></p><p>이를 3차원 좌표로 표현하면 다음과 같다.</p><p><img data-src="/assets/img/dev/week14/projection.png" data-proofer-ignore></p><p>전방을 z, 오른쪽을 y, 아래를 x인 카메라 좌표계로 되어 있고, 3차원 공간에 존재하는 객체 P에 대해 이미지에 투영한다. 식은 위의 식과 거의 동일하다.</p><p>$ y : f = h : Z , Z = \cfrac{f * h}{y} $</p><p><br /></p><p>이를 구하기 위해서는 ZX plane 뿐만이 아닌, ZY plane을 사용해야 한다. 또한 객체가 지면에 붙어 있지 않는다면 추정을 하기 어렵다. 예를 들어 신호등을 인식했지만, 기둥은 추론이 되지 않았고, 신호등만 인식이 되어 있다면 지면에서 일정 높이 떨어져 있는 객체의 bbox만을 사용하여 거리를 추정해야 한다.</p><p><br /></p><h2 id="field-of-view">Field of View <a href="#field-of-view" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>카메라의 대상 객체의 특성을 활용한 방법으로 카메라의 고유한 특성(intrinsic , sensor, lens의 속성)과 대상 객체의 실제 크기 정보를 활용하는 방법이다. 이는 extrinsic calibration 정보에 대해 상대적으로 의존도가 낮다.</p><p>FOV(Field of View)를 사용하면 ZY plane에 대한 거리 정보와 지면에서 일정 높이 떨어져 있는 객체에 대한 거리를 추정할 수 있다.</p><p><img data-src="/assets/img/dev/week14/fov.png" data-proofer-ignore></p><p>카메라가 좌표계 원점에 존재하고, 사각형이 이미지일 때, 가로를 width, 세로를 height라 할 수 있다. 이 때, width와 height에 대해 $ FOV_v $ 와 $ FOV_H $ 가 존재한다. v는 vertical, h는 horizontal이고, FOV는 $ ^{\circ} $ 단위로 표기한다. 이미지와 원점간의 거리를 <code class="language-plaintext highlighter-rouge">f</code>라 할 수 있다.</p><p>FOV가 커질수록 실제 공간을 더 넓게 투영하여 이미지로 표현할 수 있을 것이고, FOV가 작을수록 실제 공간을 더 좁게 투영하여 이미지를 표현할 수 있다.</p><p><br /></p><p><img data-src="/assets/img/dev/week14/fov2d.png" data-proofer-ignore></p><p>간단하게 2차원으로 보자.</p><p>실제 객체는 <code class="language-plaintext highlighter-rouge">H</code>의 높이를 가지고, 객체와 렌즈 사이의 거리를 $ D_o $, 이미지 안에서의 객체 높이를 <code class="language-plaintext highlighter-rouge">h</code>, 이미지와 렌즈 사이의 거리를 $ D_f $ 라 한다. F는 focal length이다. 그리고 $ \alpha $는 이미지 안에서 객체의 bbox에 대한 FOV_H값이다. 즉 bbox 위와 아래가 이루는 각도이다.</p><p>이 때, 수식 $ \cfrac{1}{D_o} + \cfrac{1}{D_f} = \cfrac{1}{F} $ 에 의해 $ D_o = \cfrac{D_f * F}{D_f - F} $ 로 표현된다. 그리고, $ tan(\cfrac{\alpha}{2}) = \cfrac{h}{2 D_f} $ 이므로, D_o 는 다음과 같다.</p>\[D_o = \cfrac{F * \cfrac{h}{2 tan\cfrac{\alpha}{2}}}{\cfrac{h}{2 tan\cfrac{\alpha}{2}} - F}\]<p><br /></p><p>이 때, a는 FOV로 계산이 가능하고, 다른 변수도 모두 알고 있는 값이므로 이미지 내에서의 object의 크기와 위치를 알면 D_o를 구할 수 있다.</p><p><br /></p><p>더 자세한 설명을 위해 가상의 카메라의 intrinsic, FOV를 다음과 같이 정의하자.</p><p><img data-src="/assets/img/dev/week14/fov_ex.png" data-proofer-ignore></p><ul><li>image size : 1280px, 720 px<li>fx = 1000, fy = 1000<li>cx = 640, cy = 360<li>$ FOV_H = 80 ^{\circ} $, $ FOV_V = 40 ^{\circ} $</ul><p>이미지 내 표지판의 위치에 대한 값</p><ul><li>bbox size : 40px, 40px<li>center about bbox bottom to bbox bottom : 940px<li>image center to bbox left bottom : 640px</ul><p>바운딩 박스의 좌하단과 height 방향으로의 직선 사이의 각도를 $ \theta $ 라 한다. 그리고 실제 표지판의 크기는 반지름이 0.5m이다. 어차피 대부분의 경우 사각형을 기준으로 측정하므로 w = 1m, h = 1m 로 할 수 있다.</p><p>$ FOV_{H(640)} = 0 ^{\circ} $ 인 이유는 이미지를 기준으로 중앙이 0, 왼쪽 방향이 (-), 오른쪽 방향이 (+)이다. 따라서 $ FOV_{H} $ 의 범위는 -40 ~ 40 이다.</p><p><br /></p><p>이미지의 중점을 기준으로 객체의 중점과의 이루는 방위각이 $ \theta $ 이고, 비례식 $ 640 : 300 = 40 : \theta $ 을 세워서 계산한다.</p><p>$ \theta = \cfrac{\triangle x}{640} * 40.0 ^{\circ} = \cfrac{300}{640} * 40.0 = 18.75 ^{\circ} $</p><p>$ \theta $ 를 구했다면, 표지판과의 거리를 구할 수 있다.</p><p>$ D_o = \cfrac{F * \cfrac{h}{2 tan\cfrac{\alpha}{2}}}{\cfrac{h}{2 tan\cfrac{\alpha}{2}} - F} = \cfrac{1000 * \cfrac{40}{2 tan(18.75 ^{\circ})}}{\cfrac{40}{2 tan(18.75 ^{\circ} )} - 1000} $</p><p>그리고 종방향과 횡방향의 분리를 위해 dx, dy로 분리한다.</p>\[d_x = d * cos(\theta) , d_y = d * sin(\theta)\]<p><br /></p><p>이때까지는 FOV_H 를 사용하여 구했지만, FOV_V를 사용하여 구할 수도 있다.</p><p><img data-src="/assets/img/dev/week14/distance.png" data-proofer-ignore></p><p>FOV_H에 대한 좌표와 값들은 빨간색에 해당되고, FOV_V는 파란색에 해당한다.</p><p><br /></p><p><br /></p><blockquote><ul><li><strong>평면의 특성을 활용한 방법</strong></ul><p><img data-src="/assets/img/dev/week14/projection2.png" data-proofer-ignore> <img data-src="/assets/img/dev/week14/fov_ex.png" data-proofer-ignore></p></blockquote><blockquote><p>여기서 bbox 각각의 좌표를 a,b,c,d 라 표현했을 때, 각각의 좌표는 다른 값을 가지고 있겠지만, 다른 평면으로 바라봤을 때는 직선으로 표현될 것이고, 그것이 첫번째 이미지가 된다.</p></blockquote><blockquote><p>그렇다면 bbox 각각의 좌표는 다 동일한 distance, d과 높이 R을 가지고 있으므로 다음과 같은 비례식을 사용할 수 있다.</p></blockquote><blockquote> \[r_a : f = d : R_a\]</blockquote><blockquote> \[r_b : f = d : R_b\]</blockquote><blockquote><p>이를 정리하여 <code class="language-plaintext highlighter-rouge">d</code>에 대해 정리하면 $ d = \cfrac{(r_b - r_a) * (R_b - R_a) }{f} = \cfrac{40px * 1m}{1000px} $ 로 정리될 수 있다.</p></blockquote><blockquote><p>그러나 이 방법은 extrinsic에 의존적이라 잘 설정해줘야 한다.</p></blockquote><p><br /></p><p><br /></p><p>위의 두 방법(geometric method, FOV) 는 복잡한 기하학적 변환이나 수식이 들어가 이해하기 어려운 단점이 있다.</p><h2 id="perspective-projection-method">Perspective Projection Method <a href="#perspective-projection-method" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>또 다른 방법으로 평면 변환(plane transform)이 있다. 이 방법에는 객체가 지정하고자 하는 평면과 관련이 있어야 하는 단점이 존재한다.</p><p><br /></p><h3 id="homography">Homography <a href="#homography" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>perspective projection method의 대표적인 방법으로 homography가 있다.</p><p><br /></p><p>이를 위해서는 평면과 평면 변환에 대해 알고 있어야 한다. 투영(projection)이란, 3차원 공간에 존재하는 어떤 대상을 2차원 이미지 공간(평면)에 투영하는 과정이다. 이미지를 다룬다면 언제나 1개 이상의 평면을 사용하고 있다. 이 평면을 image coordinate에서 정의되는 image plane이라고 한다.</p><p><img data-src="/assets\img\dev\week14\image_plane.png" data-proofer-ignore></p><p><br /></p><p>3차원 공간에 존재하는 어떤 점이 2차원 평면에 투영한다고 할 때, 3차원 공간은 무한 개의 평면을 가지고 있다. 그래서 간단하게 보기 위해 하나의 평면으로 표시하게 되면, 2차원 투영 좌표는 (x,y)에서 (x,y,1)로 , 3차원 평면의 좌표는 (X,Y,Z)에서 (X,Y,1)이 된다.</p><p>이처럼 3차원 공간 상에 놓여진 하나의 2차원 평면을 표현할 때 homogeneous 좌표계를 사용한다. homogeneous 좌표계에서는 2차원 점이 3차원으로 투영이 된다.</p><p><br /></p><p><img data-src="/assets\img\dev\week12\day4\projectionmatrix.png" data-proofer-ignore></p><p>그렇다면 카메라 좌표계를 기준으로 normalized image coordinate 좌표계에서의 점과 image coordinate에서의 점을 3차원으로 변환할 수 있다.</p><p>카메라 좌표계에서 Z는 전방을 가리킨다. 이 때 normalized image coordinate는 원점으로부터 <code class="language-plaintext highlighter-rouge">1</code>만큼 떨어져 있고, image coordinate는 <code class="language-plaintext highlighter-rouge">f</code>, 실제 좌표계에서의 점은 <code class="language-plaintext highlighter-rouge">Z</code>만큼 떨어져 있다. 그래서 각각의 점들을 변환한다.</p><ul><li>normalized image coordinate : $ (u_n, v_n, 1) $<li>image coordinate : $ (f_x, f_y, f) $<li>world coordinate : $ (X_{w_o}, Y_{w_o}, Z_{w_o}) $</ul><p>homogeneous 좌표계에서는 같은 투영선(projection ray) 상에 있는 좌표들은 다 동일한 점이라고 판단한다. 결과적으로 homogeneous 좌표계는 3차원 공간을 2차원 공간으로 투영하면 무한개의 점으로 표현이 가능해진다. 그러나 어떤 이미지 공간에 투영하는가에 따라 달라지는 것이지만, 그 대상은 동일하다. 2차원을 3차원으로 변환하는 것을 <code class="language-plaintext highlighter-rouge">Inverse-Projection</code>이라 부른다.</p><p><br /></p><p>이미지 평면에서 정규 이미지 평면으로 변환하는 것을 평면 변환(projective transform)의 한 종류로 볼 수 있다. 평면의 좌표계 기준은 달라지지 않았지만, 차선과 같이 실제 공간에서는 평행하는 두 선이 이미지 상에서는 만나지도록 변환이 된다.</p><p><br /></p><p>projective geometry의 성질을 이용한 이미지 평면을 다른 평면으로 변환하는 것도 가능하다. 이를 활용한 대표적인 예가 BEV(bird eye view) 변환이다. 같은 높이에서 바라보는 방향과 새처럼 위에서 바라보는 방향은 다르다. 위에서 아래로 바라보는 시점을 BEV라 한다.</p><p>원래의 이미지 상에서는 차선들이 소실점에서 만나게 된다. 그러나 이를 BEV로 변환하게 되면 차선들이 다시 평행하게 보인다. 원래 카메라 이미지 상에서 객체의 bbox, class를 추출하고 이를 bird`s eye view에 투영시켜서 회피를 할지 말지를 결정한다.</p><p><br /></p><p><img data-src="/assets/img/dev/week14/figure1.png" data-proofer-ignore></p><p>여기서 ground plane은 실제 지면을 의미하고 이는 <code class="language-plaintext highlighter-rouge">m</code>단위를 사용하고 있다. 카메라로 보는 이미지 a를 c로 바꾸는 작업을 수행하는 것을 perspective transformation이라 하고, 원래의 이미지 a에서는 pixel단위이고, BEV인 c에서는 <code class="language-plaintext highlighter-rouge">m</code>단위를 사용한다. BEV도 이미지이므로 pixel 단위라고 생각할 수 있지만 이는 틀렸다.</p><p>2차원 좌표계에서 데이터를 부르는 단위를 <code class="language-plaintext highlighter-rouge">Pixel</code>이라 하고, 3차원 좌표계에서 데이터를 부르는 단위를 <code class="language-plaintext highlighter-rouge">Voxel</code>이라 하는데, 픽셀이 이미지 해상도를 의미하지는 않는다. 즉 이미지를 부르는 방법이 픽셀이지 모든 픽셀이 이미지를 의미하는 것은 아니다.</p><p><br /></p><p><br /></p><h2 id="geometrical-distance-estimation-code">Geometrical Distance Estimation code <a href="#geometrical-distance-estimation-code" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>본질적으로 원근 변환(perspective transform)과 투영 변환(projective transform, homography)은 동일하다. 원근 변환은 투영 변환이지만, 투영 변환은 원근 변환일 필요는 없다. 개념과 변환의 결과는 동일하지만 투영 변환이 조금 더 상위 개념이다. 대체로 같은 것으로 판단한다.</p><p>openCV에서 제공하는 homography와 perspective transformation에 대해 공부하고자 한다. 이는 geometrical distance estimation을 수행할 때 반드시 필요한 intrinsic matrix와 extrinsic matrix에 대한 개념과 공부를 하기에 적절하다.</p><h3 id="homography-1">Homography <a href="#homography-1" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>tutorial : https://docs.opencv.org/4.x/d9/dab/tutorial_homography.html</p><p>먼저 homography를 공부하고자 한다. openCV에서는 평면 변환을 위한 함수를 제공한다.</p><ul><li>getPerspectiveTransform()<li>findHomography()</ul><p><img data-src="/assets/img/dev/week14/getperspectivetransform.png" width="55%" data-proofer-ignore> <img data-src="/assets/img/dev/week14/findhomography.png" width="40%" data-proofer-ignore></p><p>이 두 함수는 동일하지만, 입력 인자가 조금 다르다. 전자의 경우 4개의 점들을 입력으로 받지만, 후자의 경우 4개 이상의 점들을 입력으로 받는다. 4개의 점을 가지고 있다면 전자를 사용하고, 4개 이상의 점들을 가지고 있어서 좀 더 정확한 변환을 하고자 하거나, 점들 사이에 존재하는 오차를 알아서 제거해주길 원하는 경우에는 후자를 사용하는 것이 좋다. 그리고 findhomography의 경우 입력 포인트들을 통해 변환 행렬을 계산할 때 오차를 발생시키는 값을 제거하는 방법(RANSAC)이 포함되어 있다.</p><p><br /></p><p>Geometrical Method에서는 카메라와 지면이 서로 평행하다는 것을 가정했지만, 실제로는 완벽하게 평행할 수 없다. 그래서 카메라의 자세를 추정하는 별도의 알고리즘을 또 사용해야 한다. 즉 이미지를 취득한 후 소실점/소실선을 이용한 카메라 자세를 추정한 후 객체와의 거리를 추정한다. 그러나 이 평면 변환의 경우 이미지와 그 타겟이 되는 가상의 평면에 대한 변환 과정을 다루기 때문에 <strong>카메라와 지면이 서로 평행하지 않아도 된다</strong>. 즉 어떤 카메라의 자세든 변환이 가능하다.</p><p><br /></p><p><br /></p><p>이전에 배웠던 camera calibration 코드를 먼저 보자.</p><p>이 코드에서는 캘리브래이션 패턴에 존재하는 특징(코너)를 검출한다. 가장 중요한 것은 imgpoints와 objpoints의 pair 데이터를 만드는 것이 중요하다. 그 이유는 추후에 distance estimation을 할 때는 image가 아닌 pair 데이터를 사용하기 때문이다.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="n">cv2</span>
<span class="kn">import</span> <span class="n">glob</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="n">time</span>
<span class="kn">import</span> <span class="n">sys</span>

<span class="n">DISPLAY_IMAGE</span> <span class="o">=</span> <span class="bp">False</span>

<span class="c1"># Get Image Path List
</span><span class="n">image_path_list</span> <span class="o">=</span> <span class="n">glob</span><span class="p">.</span><span class="nf">glob</span><span class="p">(</span><span class="s">"images/*.jpg"</span><span class="p">)</span>

<span class="c1"># Chessboard Config
</span><span class="n">BOARD_WIDTH</span> <span class="o">=</span> <span class="mi">9</span>
<span class="n">BOARD_HEIGHT</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">SQUARE_SIZE</span> <span class="o">=</span> <span class="mf">0.025</span>

<span class="c1"># Calibration Config
</span><span class="n">flags</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">cv2</span><span class="p">.</span><span class="n">CALIB_CB_ADAPTIVE_THRESH</span>
    <span class="o">+</span> <span class="n">cv2</span><span class="p">.</span><span class="n">CALIB_CB_NORMALIZE_IMAGE</span>
    <span class="o">+</span> <span class="n">cv2</span><span class="p">.</span><span class="n">CALIB_CB_FAST_CHECK</span>
<span class="p">)</span>

<span class="n">pattern_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">BOARD_WIDTH</span><span class="p">,</span> <span class="n">BOARD_HEIGHT</span><span class="p">)</span>
<span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>

<span class="n">image_points</span> <span class="o">=</span> <span class="nf">list</span><span class="p">()</span>

<span class="s">''' =========== calibration pattern's corner detection =========='''</span>
<span class="k">for</span> <span class="n">image_path</span> <span class="ow">in</span> <span class="n">image_path_list</span><span class="p">:</span>
    <span class="n">image</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="nf">imread</span><span class="p">(</span><span class="n">image_path</span><span class="p">,</span> <span class="n">cv2</span><span class="p">.</span><span class="n">IMREAD_COLOR</span><span class="p">)</span>
    <span class="c1"># OpneCV Color Space -&gt; BGR
</span>    <span class="n">image_gray</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="nf">cvtColor</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">cv2</span><span class="p">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span>

    <span class="n">ret</span><span class="p">,</span> <span class="n">corners</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="nf">findChessboardCorners</span><span class="p">(</span><span class="n">image_gray</span><span class="p">,</span> <span class="n">pattern_size</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ret</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">DISPLAY_IMAGE</span><span class="p">:</span>
            <span class="n">image_draw</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="nf">drawChessboardCorners</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">pattern_size</span><span class="p">,</span> <span class="n">corners</span><span class="p">,</span> <span class="n">ret</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">corner</span> <span class="ow">in</span> <span class="n">corners</span><span class="p">:</span>
                <span class="n">counter_text</span> <span class="o">=</span> <span class="nf">str</span><span class="p">(</span><span class="n">counter</span><span class="p">)</span>
                <span class="n">point</span> <span class="o">=</span> <span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">corner</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span> <span class="nf">int</span><span class="p">(</span><span class="n">corner</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">cv2</span><span class="p">.</span><span class="nf">putText</span><span class="p">(</span><span class="n">image_draw</span><span class="p">,</span> <span class="n">counter_text</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">cv2</span><span class="p">.</span><span class="nf">imshow</span><span class="p">(</span><span class="s">"img"</span><span class="p">,</span> <span class="n">image_draw</span><span class="p">)</span>
            <span class="n">cv2</span><span class="p">.</span><span class="nf">waitKey</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">image_points</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">corners</span><span class="p">)</span>

<span class="n">object_points</span> <span class="o">=</span> <span class="nf">list</span><span class="p">()</span>
<span class="n">object_points</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">asarray</span><span class="p">(</span><span class="n">object_points</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span> <span class="c1"># change numpy array
</span></pre></table></code></div></div><p><br /></p><p><br /></p><ul><li><strong>camera calibration</strong></ul><p>1개의 이미지를 통해 intrinsic, extrinsic 정보를 얻어오는 코드이다.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="s">''' =========== camera calibration =========='''</span>
<span class="n">tmp_image</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="nf">imread</span><span class="p">(</span><span class="s">"images/left01.jpg"</span><span class="p">,</span> <span class="n">cv2</span><span class="p">.</span><span class="n">IMREAD_ANYCOLOR</span><span class="p">)</span>
<span class="n">image_shape</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">shape</span><span class="p">(</span><span class="n">tmp_image</span><span class="p">)</span>

<span class="n">image_height</span> <span class="o">=</span> <span class="n">image_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">image_width</span> <span class="o">=</span> <span class="n">image_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">image_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">image_width</span><span class="p">,</span> <span class="n">image_height</span><span class="p">)</span>

<span class="n">ret</span><span class="p">,</span> <span class="n">camera_matrix</span><span class="p">,</span> <span class="n">dist_coeffs</span><span class="p">,</span> <span class="n">rvecs</span><span class="p">,</span> <span class="n">tvecs</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="nf">calibrateCamera</span><span class="p">(</span><span class="n">object_points</span><span class="p">,</span> <span class="n">image_points</span><span class="p">,</span> <span class="n">image_size</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
</pre></table></code></div></div><ul><li>intrinsic<ul><li>ret : RMS(ROOT Mean Square) 오차 =&gt; extrinsic 정보와 objpoints를 가지고 이미지에 재투영하여 원래의 점과 비교해서 오차를 계산한다.<ul><li>계산했을 때 많이 튀는 노이즈 값을 필터링하는 것도 중요</ul><li>mtx : intrinsic matrix<li>dist : distortion cofficients</ul><li>extrinsic<ul><li>각 이미지에서 설정한 objpoints의 원점에 대한 실제 카메라의 extrinsic calibration 정보이다.<li>rvecs : 각 이미지에 대한 camera coordinate에서의 rotation<li>tvecs : 각 이미지에 대한 camera coordinate에서의 translation</ul></ul><p><br /></p><p><br /></p><ul><li><strong>get homography matrix</strong></ul><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="s">''' =========== homography matrix =========='''</span>
<span class="c1"># Part 2. Find homography matrix
# Step A. Select images
</span><span class="n">img1</span> <span class="o">=</span> <span class="n">cv</span><span class="p">.</span><span class="nf">imread</span><span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="s">"images"</span><span class="p">,</span> <span class="s">"left01.jpg"</span><span class="p">))</span>
<span class="n">ret</span><span class="p">,</span> <span class="n">corners1</span> <span class="o">=</span> <span class="n">cv</span><span class="p">.</span><span class="nf">findChessboardCorners</span><span class="p">(</span><span class="n">img1</span><span class="p">,</span> <span class="p">(</span><span class="n">CHESSBOARD_WIDTH</span><span class="p">,</span> <span class="n">CHESSBOARD_HEIGHT</span><span class="p">))</span>
<span class="n">corners1</span> <span class="o">=</span> <span class="n">corners1</span><span class="p">.</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="n">img2</span> <span class="o">=</span> <span class="n">cv</span><span class="p">.</span><span class="nf">imread</span><span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="s">"images"</span><span class="p">,</span> <span class="s">"right13.jpg"</span><span class="p">))</span>
<span class="n">ret</span><span class="p">,</span> <span class="n">corners2</span> <span class="o">=</span> <span class="n">cv</span><span class="p">.</span><span class="nf">findChessboardCorners</span><span class="p">(</span><span class="n">img2</span><span class="p">,</span> <span class="p">(</span><span class="n">CHESSBOARD_WIDTH</span><span class="p">,</span> <span class="n">CHESSBOARD_HEIGHT</span><span class="p">))</span>
<span class="n">corners2</span> <span class="o">=</span> <span class="n">corners2</span><span class="p">.</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>


<span class="c1">## Homography
# src -&gt; dst point transformation -&gt; find matrix
# Step B. Find homography
</span><span class="n">homography</span><span class="p">,</span> <span class="n">status</span> <span class="o">=</span> <span class="n">cv</span><span class="p">.</span><span class="nf">findHomography</span><span class="p">(</span><span class="n">corners1</span><span class="p">,</span> <span class="n">corners2</span><span class="p">,</span> <span class="n">cv</span><span class="p">.</span><span class="n">RANSAC</span><span class="p">)</span>

<span class="c1"># Step C. Display Result
</span><span class="n">img_draw_matches</span> <span class="o">=</span> <span class="n">cv</span><span class="p">.</span><span class="nf">hconcat</span><span class="p">([</span><span class="n">img1</span><span class="p">,</span> <span class="n">img2</span><span class="p">])</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">corners1</span><span class="p">)):</span>
    <span class="n">pt1</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="n">corners1</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">corners1</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">pt1</span> <span class="o">=</span> <span class="n">pt1</span><span class="p">.</span><span class="nf">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">pt2</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">homography</span><span class="p">,</span> <span class="n">pt1</span><span class="p">)</span>
    <span class="n">pt2</span> <span class="o">=</span> <span class="n">pt2</span> <span class="o">/</span> <span class="n">pt2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">img1</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">pt2</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nf">int</span><span class="p">(</span><span class="n">pt2</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">pt1</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span> <span class="nf">int</span><span class="p">(</span><span class="n">pt1</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>

    <span class="n">color</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">choice</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="mi">256</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">color</span> <span class="o">=</span> <span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">color</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nf">int</span><span class="p">(</span><span class="n">color</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nf">int</span><span class="p">(</span><span class="n">color</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
    <span class="n">cv</span><span class="p">.</span><span class="nf">line</span><span class="p">(</span><span class="n">img_draw_matches</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="nf">tuple</span><span class="p">(</span><span class="n">color</span><span class="p">),</span> <span class="mi">5</span><span class="p">)</span>

<span class="n">cv</span><span class="p">.</span><span class="nf">namedWindow</span><span class="p">(</span><span class="s">"Draw Matches"</span><span class="p">,</span> <span class="n">cv</span><span class="p">.</span><span class="n">WINDOW_NORMAL</span><span class="p">)</span>
<span class="n">cv</span><span class="p">.</span><span class="nf">imshow</span><span class="p">(</span><span class="s">"Draw Matches"</span><span class="p">,</span> <span class="n">img_draw_matches</span><span class="p">)</span>
<span class="n">cv</span><span class="p">.</span><span class="nf">imwrite</span><span class="p">(</span><span class="s">"draw.png"</span><span class="p">,</span> <span class="n">img_draw_matches</span><span class="p">)</span>
<span class="n">cv</span><span class="p">.</span><span class="nf">waitKey</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></table></code></div></div><ul><li>step A<ul><li>img1은 원본 이미지, img2는 대상이 되는 이미지<li>findChessboardCorners를 사용하여 transform의 pair 데이터를 결정<li>추후 변환에 사용되는 데이터는 이미지가 아니라 pair 데이터이다.<li>pair 포인트들을 자기 마음대로 찍어도 상관은 없으나 편리함을 위해 함수를 사용한 것이다.</ul><li>step B<ul><li>이미지가 아닌 N개의 corners1, corners2 를 사용<li>cv.RANSAC은 여러 개의 pair 데이터를 사용하면서 오류가 있는 데이터는 제외하는 알고리즘</ul><li>step C<ul><li>결과 확인<li>cv.line를 사용하여 pair 데이터가 어떻게 변환이 되었는지 확인<li>cv.warpPerspective 를 사용하여 homography matrix로 이미지 자체를 변환</ul></ul><p><br /></p><p><br /></p><h4 id="convert-img-plane-to-ground-plane">convert img plane to ground plane <a href="#convert-img-plane-to-ground-plane" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><p>이때까지는 ground plane를 image plane으로 변환했다. 이제는 반대로 image plane을 ground plane으로 변환하는 과정을 수행한다.</p><ul><li>homography matrix로 카메라의 extrinsic 정보를 추출할 수 있다.<li>카메라의 POSE를 그리는 것이 중요 : drawFrameAxes()<ul><li>이 좌표가 obj point의 0index와 동일한 좌표를 가져야 한다.</ul></ul><p><br /></p><ul><li><strong>homography distance estimation</strong></ul><p>image point와 homography를 통해 거리를 추정하는 코드</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
</pre><td class="rouge-code"><pre><span class="c1"># Step A. homography distance estimation
</span><span class="kn">import</span> <span class="n">cv2</span>
<span class="kn">import</span> <span class="n">json</span>
<span class="kn">import</span> <span class="n">os</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="kn">import</span> <span class="n">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="kn">import</span> <span class="n">calibration_parser</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">calibration_json_filepath</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="s">"image"</span><span class="p">,</span> <span class="s">"cologne_000065_000019_camera.json"</span><span class="p">)</span>
    <span class="n">camera_matrix</span> <span class="o">=</span> <span class="n">calibration_parser</span><span class="p">.</span><span class="nf">read_json_file</span><span class="p">(</span><span class="n">calibration_json_filepath</span><span class="p">)</span>
    <span class="n">image</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="nf">imread</span><span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="s">"image"</span><span class="p">,</span> <span class="s">"cologne_000065_000019_leftImg8bit.png"</span><span class="p">),</span> <span class="n">cv2</span><span class="p">.</span><span class="n">IMREAD_ANYCOLOR</span><span class="p">)</span>

    <span class="c1"># extrinsic -&gt; homography src, dst
</span>    <span class="c1"># prior dst -&gt; image coordinate
</span>    <span class="c1"># present dst -&gt; vehicle coordinate (=camera coordinate)
</span>
    <span class="c1"># world's lane value
</span>    <span class="c1"># lane (inner) width -&gt; 2.5m, lane width -&gt; 0.25m
</span>    <span class="c1"># lane length -&gt; 2.0m
</span>    <span class="c1"># lane interval -&gt; 2.0m
</span>
    <span class="s">"""
    Extrinsic Calibration for Ground Plane
    z가 전방 , x,y,z
    [0, 1]
    464, 833 -&gt; 0.0, 0.0, 0.0
    1639, 833 -&gt; 0.0, 3.0, 0.0      lane width + 2 * lane inner width

    [2, 3]
    638, 709 -&gt; 0.0, 0.0, 2.0       lane length
    1467, 709 -&gt; 0.0, 3.0, 2.0

    [4, 5]
    742, 643 -&gt; 0.0, 0.0, 4.0       
    1361, 643 -&gt; 0.0, 3.0, 4.0

    [6, 7]
    797, 605 -&gt; 0.0, 0.0, 6.0
    1310, 605 -&gt; 0.0, 3.0, 6.0
    """</span>


    <span class="n">image_points</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span>
        <span class="p">[</span><span class="mi">464</span><span class="p">,</span> <span class="mi">833</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">1639</span><span class="p">,</span> <span class="mi">833</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">638</span><span class="p">,</span> <span class="mi">709</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">1467</span><span class="p">,</span> <span class="mi">709</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">742</span><span class="p">,</span> <span class="mi">643</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">1361</span><span class="p">,</span> <span class="mi">643</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">797</span><span class="p">,</span> <span class="mi">605</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">1310</span><span class="p">,</span> <span class="mi">605</span><span class="p">]</span>
    <span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="c1"># X Y Z, X -&gt; down, Z -&gt; forward, Y -&gt; Right
</span>    <span class="c1"># 실측이 중요하다.
</span>    <span class="n">object_points</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span>
        <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">3.7</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">6.0</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">3.7</span><span class="p">,</span> <span class="mf">6.0</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">12.0</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">3.6</span><span class="p">,</span> <span class="mf">12.0</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">18.0</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">3.7</span><span class="p">,</span> <span class="mf">18.0</span><span class="p">]</span>
    <span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span> <span class="c1"># z,y,x 이고, 각각의 0.0 자리에 z는 extrinsic에 있는 z를 넣으면 실제 카메라의 위치에 대한 축을 생성할 수 있음
</span>
    <span class="n">DATA_SIZE</span> <span class="o">=</span> <span class="mi">8</span>

    <span class="c1"># object point
</span>    <span class="c1"># X: forward, Y: left, Z: 1
</span>    <span class="c1"># homography를 하기 위해서는 0index와 (1,2)index를 떼어내서 카메라 좌표계로 변환해줘야 한다. (2,-1,0)
</span>    <span class="c1"># homo에서 계산을 편하게 하기 위해 z를 사용하지 않으려고 1로 지정
</span>    <span class="n">homo_object_point</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">object_points</span><span class="p">[:,</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="o">-</span><span class="n">object_points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">homo_object_point</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">homo_object_point</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="nf">ones</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">DATA_SIZE</span><span class="p">]).</span><span class="n">T</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="nf">print</span><span class="p">(</span><span class="n">homo_object_point</span><span class="p">)</span>


    <span class="c1"># 지면에 대해서 위치와 자세 추정이 가능하다면,
</span>    <span class="c1"># 임의의 포인트를 생성하여 이미지에 투영할수있다.
</span>    <span class="c1"># extrinsic은 차량의 중심축에 대한 값들이므로 , 객체와 차량의 중심축으로부터의 거리를 다 계산할 수 있고, 이를 통해 범퍼까지의 거리를 계산할 수 있다.
</span>    <span class="n">retval</span><span class="p">,</span> <span class="n">rvec</span><span class="p">,</span> <span class="n">tvec</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="nf">solvePnP</span><span class="p">(</span><span class="n">object_points</span><span class="p">,</span> <span class="n">image_points</span><span class="p">,</span> <span class="n">camera_matrix</span><span class="p">,</span> <span class="n">distCoeffs</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">useExtrinsicGuess</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">cv2</span><span class="p">.</span><span class="n">SOLVEPNP_EPNP</span><span class="p">)</span>

    <span class="c1"># 잘 맞지 않는다.
</span>    <span class="c1"># 왜냐하면, 이미지 좌표와 실제 오브젝트와의 관계가 부정확하기 때문
</span>    <span class="c1"># 실제 측정을 통해 개선이 가능하다.
</span>    <span class="c1"># TODO: 축과 차선의 위치가 맞지 않는 이유는 실제 이미지 좌표에 대한 거리정보를 모르기 때문에 발생됨. 실측을 통해 정확한 거리값으로 맵핑하면 잘 맞게 된다.
</span>    <span class="n">image</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="nf">drawFrameAxes</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">camera_matrix</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">rvec</span><span class="p">,</span> <span class="n">tvec</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>

    <span class="c1"># proj_image_points, _ = cv2.projectPoints(object_points, rvec, tvec, camera_matrix, None)
</span>    <span class="c1"># print(proj_image_points) # TODO: 정확한 obj point를 한다면 출력값이 image points와 같은 값을 가질 것
</span>
    <span class="n">homography</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="nf">findHomography</span><span class="p">(</span><span class="n">image_points</span><span class="p">,</span> <span class="n">homo_object_point</span><span class="p">)</span> <span class="c1"># None 이 나온다면 두 shape이 맞지 않기 때문이다.
</span>    <span class="c1"># print(proj_image_points.shape)
</span>    
    <span class="c1"># (u, v) -&gt; (u, v, 1)
</span>    <span class="n">appned_image_points</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">image_points</span><span class="p">.</span><span class="nf">reshape</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="p">.</span><span class="nf">ones</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">DATA_SIZE</span><span class="p">]).</span><span class="n">T</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># print(homography.shape)
</span>
    <span class="k">for</span> <span class="n">image_point</span> <span class="ow">in</span> <span class="n">appned_image_points</span><span class="p">:</span>
        <span class="c1"># estimation point(object_point) -&gt; homography * src(image_point)
</span>        <span class="n">estimation_distance</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">homography</span><span class="p">,</span> <span class="n">image_point</span><span class="p">)</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">estimation_distance</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">estimation_distance</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">estimation_distance</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="nf">print</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">z</span><span class="p">,</span> <span class="n">y</span><span class="o">/</span><span class="n">z</span><span class="p">,</span> <span class="n">z</span><span class="o">/</span><span class="n">z</span><span class="p">)</span> <span class="c1"># homogeneous 좌표게에서는 마지막이 항상 1이어야 하므로 나눔
</span>        <span class="c1"># homo object point와 비교하여 얼마나 차이나는지 확인
</span></pre></table></code></div></div><ul><li>순서<ol><li>실제 측량을 통해 obj point와 image point를 생성<li>random의 intrinsic 정보를 설정<li>opj point는 world 좌표계이므로 이를 카메라 좌표계로 변환<li>solvePnp를 통해 카메라 위치 추정 rotation, translation vector를 얻고 그를 통해 drawFrameAxes<li>이미지 좌표와 실제 오브젝트의 관계를 수정<li>projectPoints를 통해 iamge point와 object point가 거의 동일한지 확인<li>findHomography를 통해 iamge point와 object point에 대한 변환행렬 생성<li>iamge point의 좌표계를 homogeneous 좌표계로 변환<li>각 image point에 대해 homography를 곱하여 거리를 추정</ol></ul><p>여기서 중요한 점 : 호모그래피는 평면과 평면 사이의 변환을 의미한다. 따라서 바닥면이 평면이 아니라면 사용하기 어렵다.</p><p><br /></p><p><br /></p><ul><li><strong>geometrical distance estimation</strong></ul><p>intrinsic을 통해 이미지 왜곡 보정 및 bbox에 대한 거리 추정한 값을 실제와 비교하는 코드</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
</pre><td class="rouge-code"><pre><span class="c1"># Step B. geometrical distance estimation
</span>
<span class="kn">import</span> <span class="n">json</span>
<span class="kn">import</span> <span class="n">cv2</span>
<span class="kn">from</span> <span class="n">cv2</span> <span class="kn">import</span> <span class="n">undistort</span>
<span class="kn">import</span> <span class="n">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">import</span> <span class="n">os</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="c1"># file parsing
</span><span class="n">json_file_path</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="s">"data"</span><span class="p">,</span> <span class="s">"000076.json"</span><span class="p">)</span>
<span class="n">image_file_path</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="s">"data"</span><span class="p">,</span> <span class="s">"1616343619200.jpg"</span><span class="p">)</span>

<span class="n">window_name</span> <span class="o">=</span> <span class="s">"Perception"</span>

<span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="n">json_file_path</span><span class="p">,</span> <span class="s">"r"</span><span class="p">)</span> <span class="k">as</span> <span class="n">json_file</span><span class="p">:</span>
    <span class="n">labeling_info</span> <span class="o">=</span> <span class="n">json</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="n">json_file</span><span class="p">)</span>

<span class="n">image</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="nf">imread</span><span class="p">(</span><span class="n">image_file_path</span><span class="p">,</span> <span class="n">cv2</span><span class="p">.</span><span class="n">IMREAD_ANYCOLOR</span><span class="p">)</span>

<span class="n">camera_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">asarray</span><span class="p">(</span><span class="n">labeling_info</span><span class="p">[</span><span class="s">"calib"</span><span class="p">][</span><span class="s">"cam01"</span><span class="p">][</span><span class="s">"cam_intrinsic"</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">dist_coeff</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">asarray</span><span class="p">(</span><span class="n">labeling_info</span><span class="p">[</span><span class="s">"calib"</span><span class="p">][</span><span class="s">"cam01"</span><span class="p">][</span><span class="s">"distortion"</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">undist_image</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="nf">undistort</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">camera_matrix</span><span class="p">,</span> <span class="n">dist_coeff</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

<span class="n">labeling</span> <span class="o">=</span> <span class="n">labeling_info</span><span class="p">[</span><span class="s">"frames"</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">"annos"</span><span class="p">]</span>
<span class="n">class_names</span> <span class="o">=</span> <span class="n">labeling</span><span class="p">[</span><span class="s">"names"</span><span class="p">]</span>
<span class="n">boxes_2d</span> <span class="o">=</span> <span class="n">labeling</span><span class="p">[</span><span class="s">"boxes_2d"</span><span class="p">][</span><span class="s">"cam01"</span><span class="p">]</span>

<span class="n">CAMERA_HEIGHT</span> <span class="o">=</span> <span class="mf">1.3</span> <span class="c1"># TODO: 이 값에 따라 거리가 크게 바뀜. 지면과 카메라가 바라보는 방향이 이루는 각이 특정한 각을 이룬다면 pitch에 대한 보정이 필요하다.
</span>
<span class="c1"># distance = f * height / img(y)
# 종/횡 방향으로 분리된 거리가 아닌, 직선거리
# FOV 정보를 알면 -&gt; 종/횡 분리가 가능하다.
</span>
<span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">class_name</span><span class="p">,</span> <span class="n">bbox</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">class_names</span><span class="p">,</span> <span class="n">boxes_2d</span><span class="p">):</span>
    <span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="n">bbox</span>
    <span class="n">xmin</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">xmin</span><span class="p">)</span>
    <span class="n">ymin</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">ymin</span><span class="p">)</span>
    <span class="n">xmax</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">xmax</span><span class="p">)</span>
    <span class="n">ymax</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">ymax</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">xmin</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">ymin</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">xmax</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">ymax</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># if -1, pass
</span>        <span class="k">continue</span>

    <span class="n">width</span> <span class="o">=</span> <span class="n">xmax</span> <span class="o">-</span> <span class="n">xmin</span>
    <span class="n">height</span> <span class="o">=</span> <span class="n">ymax</span> <span class="o">-</span> <span class="n">ymin</span>

    <span class="c1"># Normalized Image Plane
</span>    <span class="n">y_norm</span> <span class="o">=</span> <span class="p">(</span><span class="n">ymax</span> <span class="o">-</span> <span class="n">camera_matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">camera_matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">distance</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">CAMERA_HEIGHT</span> <span class="o">/</span> <span class="n">y_norm</span>

    <span class="nf">print</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">distance</span><span class="p">))</span>
    <span class="n">cv2</span><span class="p">.</span><span class="nf">rectangle</span><span class="p">(</span><span class="n">undist_image</span><span class="p">,</span> <span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span><span class="p">),</span> <span class="p">(</span><span class="n">xmax</span><span class="p">,</span> <span class="n">ymax</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">cv2</span><span class="p">.</span><span class="nf">putText</span><span class="p">(</span><span class="n">undist_image</span><span class="p">,</span> <span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s">-</span><span class="si">{</span><span class="n">class_name</span><span class="si">}</span><span class="s">-</span><span class="si">{</span><span class="nf">int</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span><span class="si">}</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span><span class="o">+</span><span class="mi">25</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="n">display_image</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="nf">cvtColor</span><span class="p">(</span><span class="n">undist_image</span><span class="p">,</span> <span class="n">cv2</span><span class="p">.</span><span class="n">COLOR_BGR2RGB</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">imshow</span><span class="p">(</span><span class="n">display_image</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">show</span><span class="p">()</span>
</pre></table></code></div></div><ul><li>순서<ol><li>실제 객체와 카메라 사이의 거리를 측정<li>카메라 intrinsic, distortion 획득<li>undistorting image<li>bbox 정보 저장<li>bbox 정보에 대한 fy, cy를 가져와서 normalized image plane 구함<li>distance 저장<li>실제 거리와 distance가 맞는지 확인하고, 실제 camera 높이도 측정하여 camera height를 조정<li>만약 높이가 맞다면 intrinsic이 틀렸거나 bbox가 틀리게 나온 것<li>bbox가 맞게 들어오고 있는지 확인을 위해 visualize<li>맞다면 intrinsic 조정</ol></ul><p><br /></p><p><br /></p><ul><li>calibration_parser.py</ul><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="n">json</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="k">def</span> <span class="nf">read_json_file</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"="</span> <span class="o">*</span> <span class="mi">50</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Read JSON File: "</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"="</span> <span class="o">*</span> <span class="mi">50</span><span class="p">)</span>
    <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">"r"</span><span class="p">,)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">calibration_json</span> <span class="o">=</span> <span class="n">json</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="n">intrinsic</span> <span class="o">=</span> <span class="n">calibration_json</span><span class="p">[</span><span class="s">"intrinsic"</span><span class="p">]</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Intrinsic Calibration</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">intrinsic</span><span class="p">)</span>
    <span class="n">extrinsic</span> <span class="o">=</span> <span class="n">calibration_json</span><span class="p">[</span><span class="s">"extrinsic"</span><span class="p">]</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Extrinsic Calibration</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">extrinsic</span><span class="p">)</span>

    <span class="n">camera_matrix</span> <span class="o">=</span> <span class="nf">parse_intrinsic_calibration</span><span class="p">(</span><span class="n">intrinsic</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">camera_matrix</span>

<span class="s">"""
    [
        [fx, 0, cx = u0],
        [0, fy, cy = v0],
        [0,  0,  1]
    ]
"""</span>

<span class="k">def</span> <span class="nf">parse_intrinsic_calibration</span><span class="p">(</span><span class="n">intrinsic</span><span class="p">):</span>
    <span class="n">fx</span> <span class="o">=</span> <span class="n">intrinsic</span><span class="p">[</span><span class="s">"fx"</span><span class="p">]</span>
    <span class="n">fy</span> <span class="o">=</span> <span class="n">intrinsic</span><span class="p">[</span><span class="s">"fy"</span><span class="p">]</span>
    <span class="n">cx</span> <span class="o">=</span> <span class="n">intrinsic</span><span class="p">[</span><span class="s">"u0"</span><span class="p">]</span>
    <span class="n">cy</span> <span class="o">=</span> <span class="n">intrinsic</span><span class="p">[</span><span class="s">"v0"</span><span class="p">]</span>
    <span class="n">camera_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">camera_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">fx</span>
    <span class="n">camera_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cx</span>
    <span class="n">camera_matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">fy</span>
    <span class="n">camera_matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cy</span>
    <span class="n">camera_matrix</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="k">return</span> <span class="n">camera_matrix</span>
</pre></table></code></div></div><h1 id="summary">Summary</h1><p>3차원 정보를 복원하는 방법</p><ol><li>카메라의 extrinsic을 이용하는 방법<ul><li>지면과 카메라 광학축을 활용한 삼각비</ul><li>카메라의 intrinsic과 대상 객체의 사전 정보를 이용하는 방법<ul><li>FOV를 활용하여 이미지 bbox에 대한 dx, dy를 구하는 방법<li>geometrical distance estimation</ul><li>카메라의 image plane과 대상 plane의 변환 matrix를 사용하는 방법<ul><li>warpPerspectiveTransform, findHomography<li>homography distance estimation</ul></ol><p>카메라는 본질적으로 3차원 공간에 대한 정보가 이미지를 취득하는 동시에 소실되기 때문에 3차원 공간에 대한 이해가 굉장히 어렵다.</p><p><br /></p><p>이때까지는 1개의 카메라(Monocular camera)를 사용한 3D vision 방법을 배웠다. 그러나 카메라는 1개만 사용하는 것은 불가능하기에 multiple camera를 사용해야 하는데 이는 매우 복잡한 분야다. multiple camera에 대한 바이블인 눈깔책으로 불리는 <code class="language-plaintext highlighter-rouge">Multiple View Geometry</code> 책을 보길 추천한다.</p><p><img data-src="/assets\img\dev\week14/book.jpg" data-proofer-ignore></p></div><div class="post-tail-wrapper text-muted"><div style="text-align: left;"> <a href="http://hits.dwyl.com/dkssud8150.github.io/posts/distanceestim/" target="_blank"> <img data-src="http://hits.dwyl.com/dkssud8150.github.io/posts/distanceestim.svg" data-proofer-ignore> </a></div><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/classlog/'>Classlog</a>, <a href='/categories/devcourse/'>devcourse</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/devcourse/" class="post-tag no-text-decoration" >devcourse</a> <a href="/tags/deeplearning/" class="post-tag no-text-decoration" >deeplearning</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=[데브코스] 14주차 - DeepLearning Geometrical Distance Estimation - JaeHo Yoon&amp;url=https://dkssud8150.github.io/posts/distanceestim/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=[데브코스] 14주차 - DeepLearning Geometrical Distance Estimation - JaeHo Yoon&amp;u=https://dkssud8150.github.io/posts/distanceestim/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https://dkssud8150.github.io/posts/distanceestim/&amp;text=[데브코스] 14주차 - DeepLearning Geometrical Distance Estimation - JaeHo Yoon" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://dkssud8150.github.io/posts/distanceestim/" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6611243953442169" crossorigin="anonymous"></script></div><script src="https://utteranc.es/client.js" repo="dkssud8150/dkssud8150.github.io" issue-term="pathname" theme="github-light" crossorigin="anonymous" async> </script></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/gitpage/">[깃허브 프로필 꾸미기] github 프로필 만들기</a><li><a href="/posts/product/">[깃허브 프로필 꾸미기] productive box 만들기</a><li><a href="/posts/regex/">[데브코스] 2주차 - linux 기초(REGEX)</a><li><a href="/posts/Kfold/">KFold Cross Validation 과 StratifiedKFold</a><li><a href="/posts/cmake/">[데브코스] 17주차 - CMake OpenCV, Eigen, Pangolin install </a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/devcourse/">devcourse</a> <a class="post-tag" href="/tags/deeplearning/">deeplearning</a> <a class="post-tag" href="/tags/cs231n/">CS231N</a> <a class="post-tag" href="/tags/ros/">ros</a> <a class="post-tag" href="/tags/coding-test/">coding test</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/kooc/">kooc</a> <a class="post-tag" href="/tags/opencv/">OpenCV</a> <a class="post-tag" href="/tags/pytorch-tutorial/">pytorch tutorial</a> <a class="post-tag" href="/tags/autonomous-driving/">Autonomous Driving</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/numpy/"><div class="card-body"> <em class="timeago small" date="2022-04-11 14:40:00 +0900" >Apr 11, 2022</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[데브코스] 9주차 - DeepLearning Numpy & Matplotlib</h3><div class="text-muted small"><p> Numpy Numpy 설치 및 불러오기 pip install numpy import numpy as np 파이썬의 리스트는 머신러닝에서 가장 많이 사용되는 구조 중 하나일 것이다. 그러나 이 리스트는 연산 속도가 느리다. 그래서 연산을 효과적으로 할 수 있도록 하기 위해 만든 것이 Numpy이다. Numpy 연산 속도 nump...</p></div></div></a></div><div class="card"> <a href="/posts/dplearn/"><div class="card-body"> <em class="timeago small" date="2022-04-12 15:40:00 +0900" >Apr 12, 2022</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[데브코스] 9주차 - DeepLearning AI & machine learning</h3><div class="text-muted small"><p> 기계 학습 어떤 컴퓨터 프로그램이 T라는 작업을 수행할 때, 이 프로그램의 성능이 P라는 척도로 평가했을 때 경험 E를 통해 성능이 개선된다면 이 프로그램은 학습한다고 말할 수 있다. 따라서 최적의 알고리즘을 찾는 행위를 기계 학습이라 할 수 있다. 기계 학습의 중심은 경험, 과업, 성능에 있다. 예전에는 지식 기반의 학습을 했다. 즉, 인간이...</p></div></div></a></div><div class="card"> <a href="/posts/mlmath/"><div class="card-body"> <em class="timeago small" date="2022-04-13 15:40:00 +0900" >Apr 13, 2022</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[데브코스] 9주차 - DeepLearning Mathematics for Machine Learning</h3><div class="text-muted small"><p> 기계 학습에서 수학은 손실함수를 정의하고 손실함수의 최저점을 찾아주는 최적화 이론에 사용된다. 제어를 함에 있어서도 수학이 필요하다. 선형대수 데이터는 벡터나 행렬, 텐서 형태로 되어 있는데, 이에 대한 공간을 이해하고, 연산을 하기 위해서는 선형대수가 필요하다. 벡터와 행렬 벡터는 요소의 종료와 크기를 표현한다. [x \in R^n] ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/tstl/" class="btn btn-outline-primary" prompt="Older"><p>[lane detection] traffic sign and traffic light detection utilizing yolov3 and hough transform</p></a> <a href="/posts/distestim/" class="btn btn-outline-primary" prompt="Newer"><p>[데브코스] 14주차 - ImageProcessing geometrical distance estimation</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://twitter.com/username">JaeHo YooN</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/devcourse/">devcourse</a> <a class="post-tag" href="/tags/deeplearning/">deeplearning</a> <a class="post-tag" href="/tags/cs231n/">CS231N</a> <a class="post-tag" href="/tags/ros/">ros</a> <a class="post-tag" href="/tags/coding-test/">coding test</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/kooc/">kooc</a> <a class="post-tag" href="/tags/opencv/">OpenCV</a> <a class="post-tag" href="/tags/pytorch-tutorial/">pytorch tutorial</a> <a class="post-tag" href="/tags/autonomous-driving/">Autonomous Driving</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-NC7MWHVXJE"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-NC7MWHVXJE'); }); </script>